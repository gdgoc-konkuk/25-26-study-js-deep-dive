# 23장: 실행 컨텍스트(Execution Context)

## 실행 컨텍스트가 뭔데요?

- **엔진이 현재 실행해야 하는 코드의 모든 상태를 담고있는 Record**
- 지금 실행 중인 코드가 뭔지(Function, Script, Module)
- 어떤 스코프를 사용할지(LexicalEnvironment, VariableEnvironment 등)
- `this`가 뭔지
- 프라이빗 필드(Class Private Name Environment)를 어떻게 사용할지 등을 묶어서 가짐

### [실행 컨텍스트의 구조](https://tc39.es/ecma262/#sec-execution-contexts)

|        Component        | Purpose                                                                                                                                                          |
| :---------------------: | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _code evaluation state_ | 이 실행 컨텍스트와 연계된 코드의 평가 수행, 일시중단, 재개에 필요한 모든 상태.                                                                                   |
|       _Function_        | 이 실행 컨텍스트가 함수 객체의 코드를 평가 중이면 이 구성 요소 값은 그 함수 객체이고, Script 또는 Module의 코드를 평가 중이면 값은 null.                         |
|         _Realm_         | 연계된 코드가 ECMAScript 자원에 접근하는 데 사용하는 Realm Record.                                                                                               |
|    _ScriptOrModule_     | 연계된 코드가 기원한 Module Record 또는 Script Record. 원래 실행 컨텍스트(InitializeHostDefinedRealm에서 생성된)처럼 기원 스크립트나 모듈이 없는 경우 값은 null. |
|  _LexicalEnvironment_   | 이 실행 컨텍스트 내 코드가 수행하는 식별자 참조를 해석하는 데 사용되는 Environment Record를 식별.                                                                |
|  _VariableEnvironment_  | 이 실행 컨텍스트 내 VariableStatement에 의해 생성된 바인딩을 보유하는 Environment Record를 식별.                                                                 |
|  _PrivateEnvironment_   | 가장 가까운 둘러싸는 클래스의 ClassElement들이 생성한 Private Name들을 보유하는 PrivateEnvironment Record를 식별. 둘러싸는 클래스가 없으면 null.                 |

1. _Function_
   - 실행 중인 함수 객체
   - Script 또는 Module의 코드를 평가 중이면 값은 `null`
   - `this` 바인딩, `arguments` 생성 규칙 등 함수 내부 동작을 결정하는데 사용
1. _Realm_
   - 실행되는 코드가 속한 Realm(대충 실행 환경 내지는 샌드박스 정도로 생각하면 됨..)
   - 전역 객체(_GlobalObject_), 전역 환격(_GlobalEnv_), 빌트인 객체(_Intrinsics_)를 포함
   - `this` 바인딩, 전역 객체 및 빌트인 객체 결정
1. _ScriptOrModule_
   - _ScriptCodeEvaluation_ -> Script Record
   - _ModuleEvaluation_ -> Module Record
   - 모듈의 평가 방법이 다르기 때문에 구분하기 위해 사용
   - 모듈에 대해서 자세히 다루지 않으므로 어떻게 다른지는 패스
1. _LexicalEnvironment_
   - 현재 식별자를 찾기 위한 Environment Record 체인
1. _VariableEnvironment_
   - `var` 선언만 별도 관리되고
   - `let`, `const`, `class` 선언은 *LexicalEnvironment*에 등록되어 관리
     - `var`은 함수 레벨 스코프지만, `let`, `const`, `class`는 블록 레벨 스코프라서 별도 관리
1. _PrivateEnvironment_
   - 클래스의 `private` 필드 및 메서드 관리

### 다른 언어에도 비슷한 게 있나요?

있긴 한데, JS의 Execution Context만큼 명세화 되어있지는 않습니다.
예를 들어, C의 Stack Frame에는 단순히 함수 실행에 필요한 local var, parameter, 실행 상태만 저장합니다.

## 23.1: 소스코드의 타입

|          소스코드의 타입          | 설명                                                                                                    |
| :-------------------------------: | :------------------------------------------------------------------------------------------------------ |
|  전역 코드<sup>Global Code</sup>  | 전역에 존재하는 소스코드.<br />전역에 정의된 함수, 클래스 등의 내부 코드는 포함하지 않음.[^1]           |
| 함수 코드<sup>Function Code</sup> | 함수 내부에 존재하는 소스코드.<br />함수 내부의 중첩된 함수, 클래스 등의 내부 코드는 포함하지 않음.[^1] |
|  `eval` 코드<sup>Eval Code</sup>  | `eval` 함수로 실행되는 소스코드.                                                                        |
|  모듈 코드<sup>Module Code</sup>  | 모듈 내부에 존재하는 소스코드. <br />모듈 내부의 함수, 클래스 등의 내부 코드는 포함하지 않음.[^1]       |

[^1]:
    정확히는 _FunctionDeclaration_, _FunctionExpression_, _GeneratorDeclaration_, _GeneratorExpression_, _AsyncFunctionDeclaration_, _AsyncFunctionExpression_, _AsyncGeneratorDeclaration_, _AsyncGeneratorExpression_, _MethodDefinition_, _ArrowFunction_, _AsyncArrowFunction_, _ClassDeclaration_, _ClassExpression_ 을 포함하지 않음.\
    [참고: ECMAScript Language Specification 11.2](https://tc39.es/ecma262/#sec-types-of-source-code)

각 소스코드 타입에 따라 실행 컨텍스트가 구성되는 방식, `this` 바인딩 방식, 변수 환경 구조가 달라집니다.

1. 전역 코드
1. 함수 코드
1. `eval` 코드
1. 모듈 코드

책의 [그림 23-1]에서는 전역 코드가 평가되면 전역 실행 컨텍스트가 생성되고, 함수 코드가 평가되면 함수 실행 컨텍스트가 생성되는 등
평가되는 소스코드의 타입에 따라 생성되는 실행 컨텍스트의 종류가 다른 것처럼 서술하고 있지만,
엄밀히 말하자면...

1. 코드의 타입은 평가 알고리즘을 선택하는 기준일 뿐입니다.
1. 사실 실행 컨텍스트는 타입이 없습니다.
1. 어떤 코드가 평가되는지에 따라 *다른 형태*의 실행 컨텍스트가 생성됩니다.

## 23.2: 소스코드의 평가와 실행

### 평가(Evaluation)

- 모든 소스코드는 실행 전 평가 과정을 거칩니다.
- 평가 과정에서 실행 컨텍스트가 생성되고, 해당 실행 컨텍스트가 관리하는 스코프(실행 컨텍스트가 참조하는 *LexicalEnvironment*/*EnvironmentRecord* 안에 바인딩이 저장된다는 뜻)가 구성됩니다.
- 변수, 함수 등의 선언문만 먼저 실행하여, 생성된 변수나 함수의 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록합니다.
  - `var` 선언은 즉시 초기화(`undefined`)됩니다.
  - `let`, `const` 선언은 초기화되지 않으며 TDZ에 들어갑니다.
  - 함수 선언은 함수 객체가 생성되어 환경 레코드에 등록됩니다.

### 실행(Execution)

- 평가 과정 이후 선언문을 제외한 소스코드가 순차적으로 실행됩니다.
- 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색하여 사용합니다.
- 실행 결과는 실행 컨텍스트가 관리하는 스코프에 저장됩니다.

### 예시

```js
var x;
x = 1;
```

1. 평가
   - `var x;` 선언문을 실행하여, 스코프에 식별자 `x`를 등록하고 `undefined`로 초기화합니다.
1. 실행
   - `x = 1;`만 실행됩니다.
   - 실행 전, `x`가 선언된 변수인지 확인하기 위해, 스코프에 식별자 `x`가 등록되어 있는지 확인합니다.
   - 등록되어 있으면, `x`에 값 `1`을 할당합니다. 할당 결과는 실행 컨텍스트에 등록됩니다.
   - 등록되어 있지 않으면, `ReferenceError`가 발생합니다.

## 23.3: 실행 컨텍스트의 역할

전역 코드와 함수 코드로 구성된 다음 코드를 보고, 엔진이 어떻게 평가하고 실행할 지 생각해봅시다.

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100); // 130

// 메서드 호출
console.log(x + y); // 3
```

1. 전역 코드 평가
   - 전역 변수 `x`, `y`와 전역 함수 `foo`를 실행 컨텍스트가 관리하는 스코프에 등록합니다.
   - `var` 키워드로 선언된 전역 변수와, 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 됩니다.
1. 전역 코드 실행
   - `x = 1;`과 `y = 2;`를 실행하여, 전역 변수 `x`와 `y`에 값 `1`과 `2`를 할당합니다.
   - 할당 결과는 실행 컨텍스트에 등록됩니다.
   - `foo(100);`를 실행하여, 전역 함수 `foo`를 호출합니다.
     - 함수가 호출되면 전역 코드의 실행 컨텍스트가 일시 중단되고, 함수 코드의 실행 컨텍스트가 생성됩니다. (Stack에 `foo()`가 push)
1. 함수 코드 평가
   - 매개변수 `a`와 지역 변수 `x`, `y`를 실행 컨텍스트가 관리하는 스코프에 등록합니다.
   - 함수 내부에서 지역 변수처럼 사용할 수 있는 `arguments` 객체가 생성되어 실행 컨텍스트가 관리하는 스코프에 등록되고[^2], `this` 바인딩도 결정됩니다.
     [^2]: 엄밀히 말하면, `arguments`는 현재 함수 실행 컨텍스트의 *LexicalEnvironment*가 가리키는 *FunctionEnvironmentRecord* 안에 binding으로 존재하며, 이 레코드를 통해 식별자로 resolve됩니다. 즉 **스코프에 있다**라고 볼 수 있지만, 실행 컨텍스트 자체에 저장되는 것은 아닙니다.
1. 함수 코드 실행
   - 매개변수 `a`에 `100`, 지역 변수 `x`에 `10`, `y`에 `20`을 할당합니다.
   - `console.log(a + x + y);`를 실행합니다.
     - `console.log()`를 호출하기 위해, 스코프에 등록된 식별자 `console`을 검색합니다.
     - `console`은 전역 객체의 프로퍼티이기 때문에, 스코프 체인을 통해 전역 객체까지 올라가서 console을 찾아냅니다.
     - `log` 프로퍼티를 `console` 객체의 프로토타입 체인을 통해 검색합니다.
     - `console.log` 메서드에 인수로 전달된 `a + x + y`가 평가됩니다.
     - `a + x + y`가 평가될 때, 스코프에 등록된 식별자 `a`, `x`, `y`를 검색합니다.
   - `console.log(a + x + y);`의 실행이 종료되면 함수 코드의 실행 컨텍스트가 종료되고, 전역 코드의 실행 컨텍스트가 다시 Running context가 됩니다. (Stack에서 `foo()`가 pop)

위 과정처럼 코드가 실행되기 위해서 실행 컨텍스트는 다음의 기능을 가집니다.

1. 식별자, 바인딩 관리
   - 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분하여 등록하고
   - 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야 합니다.
   - 전역의 경우, 전역 객체가 Object Environment Record의 `BindingObject`로 사용되기 때문에 전역 객체의 프로퍼티도 전역 식별자처럼 resolve될 수 있습니다.
1. 스코프 체인을 통한 식별자 검색
   - 스코프는 중첩 관계에 의해 스코프 체인을 형성하여 식별자를 검색할 수 있어야 합니다.
   - 즉, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 합니다.
1. 실행 흐름 제어
   - 코드의 실행 순서를 변경할 수 있어야 하고, 다시 되돌아갈 수도 있어야 합니다.

이 모든 것을 관리하는 것이 바로 실행 컨텍스트이며, 실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역입니다.

구체적으로는, 실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드의 실행 순서를 관리를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리됩니다.

식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택으로 관리합니다.

## 23.4: 실행 컨텍스트 스택

```js
const x = 1;

function foo() {
  const y = 2;

  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```

전역 코드와 함수 코드로 이루어진 위 예제 코드 중 엔진은 전역 코드를 먼저 평가하여 전역 실행 컨텍스트가 생성됩니다.
그 후, 전역 코드에서 `foo()`를 호출하면 함수 코드가 평가되어 함수 실행 컨텍스트가 생성됩니다.

이때 생성된 실행 컨텍스트는 스택으로[^3] 관리되고, 이를 실행 컨텍스트 스택 또는 콜 스택이라고 합니다.
[^3]: 책에서는 스택으로 관리되는 것으로 서술하고 있지만, 실제로는 Stack-like...(`async`, generator, job queue 등 때문에)\
_Transition of the running execution context status among execution contexts usually occurs in stack-like last-in/first-out manner. However, some ECMAScript features require non-LIFO transitions of the running execution context._\
[참고: ECMAScript Language Specification 9.4](https://tc39.es/ecma262/#sec-execution-contexts)

![a-23-5.png](/images/ch23/a-23-5.png)

1. 전역 코드의 평가와 실행
   - 전역 코드 평가 후, 전역 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 push
     - 전역 변수 `x`와 전역 함수 `foo`가 전역 실행 컨텍스트에 등록
   - 실행 시 `x`에 `1`을 할당
   - `foo()` 함수 호출
1. `foo()` 함수 코드의 평가와 실행
   - `foo()` 함수의 실행 컨텍스트가 생성되고 Stack에 `foo()`의 실행 컨텍스트가 push (전역 코드 실행은 일시 중단)
   - 지역 변수 `y`와 지역 함수 `bar`가 `foo()` 함수의 실행 컨텍스트에 등록
   - 실행 시 `y`에 `2`를 할당
   - `bar()` 함수 호출
1. `bar()` 함수 코드의 평가와 실행
   - `bar()` 함수의 실행 컨텍스트가 생성되고 Stack에 `bar()`의 실행 컨텍스트가 push (`foo()` 함수 실행은 일시 중단)
   - 지역 변수 `z`가 `bar()` 함수의 실행 컨텍스트에 등록
   - 실행 시 `z`에 `3`을 할당
   - `console.log(x + y + z);` 실행
   - `bar()` 함수의 실행 컨텍스트가 종료되고, `foo()` 함수의 실행 컨텍스트로 복귀. (Stack에서 `bar()`가 pop)
1. `foo()` 함수 코드로 복귀
   - `foo()` 함수의 실행 컨텍스트가 종료되고, 전역 코드의 실행 컨텍스트로 복귀. (Stack에서 `foo()`가 pop)
1. 전역 코드로 복귀
   - 전역 코드의 실행 컨텍스트가 종료되고, 실행 컨텍스트 스택에서 pop.

## 23.5: 렉시컬 환경

- 실행 컨텍스트를 구성하는 컴포넌트 중 하나입니다.
- 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조입니다.
- 스코프와 식별자를 관리합니다.
- 키와 값을 갖는 객체 형태의 전역, 함수 또는 블록 스코프를 생성합니다.
- 렉시컬 환경은 렉시컬 스코프의 싩체입니다.

- _LexicalEnvironment_ 컴포넌트와 _VariableEnvironment_ 컴포넌트는 생성 초기 동일한 *EnvironmentRecord*를 참조합니다.
- 책에서는 생략되었지만,,, `let`, `const`, `class` 선언이 있는 블록이 실행될 때 새로운 *LexicalEnvironment*가 생성되어 등록됩니다.
- 대충 Block Scope가 나오면 분리된다고 생각하면 될 듯..
- 렉시컬 환경은 _EnvironmentRecord_, *OuterLexicalEnvironmentReference*를 가집니다.
  - *EnvironmentRecord*는 식별자와 식별자에 바인딩된 값을 관리합니다.
  - *OuterLexicalEnvironmentReference*는 상위 스코프에 대한 참조를 저장합니다.

[*EnvironmentRecord*와 *OuterLexicalEnvironmentReference*가 어떻게 결정되는지 자세히 알고 싶다면..](https://github.com/gdgoc-konkuk/25-26-study-js-deep-dive/pull/13#discussion_r2536463910)

<section>
## 23.6: 실행 컨텍스트의 생성과 식별자 검색 과정

예제를 통해 알아봅시다.

<div style={{ position: 'sticky', top: '80px', zIndex: 20, borderRadius: 'var(--x-radius-md)', boxShadow: '0 5px 15px 0 rgba(0, 0, 0, 0.07)' }}>

```js
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}

foo(20); //42
```

</div>


### 23.6.1: 전역 객체 생성

- 전역 객체는 전역 코드 평가 이전에 생성됩니다.
- 전역 객체는 다음을 포함합니다.
  - 빌트인 전역 프로퍼티(`Infinity`, `NaN`, `undefined` 등)
  - 빌트인 전역 함수(`parseInt()`, `parseFloat()`, `isNaN()`, 등)
  - 표준 빌트인 객체(Intrinsics; `Object`, `Function`, `Array`, `Promise`, `Date` 등)
  - 동작 환경에 따라 Web API 또는 특정 환경을 위한 호스트 객체(브라우저: `window`; Node.js: `global` 등)
- 전역 객체도 `Object.prototype`을 상속받으며, 프로토타입 체인의 일원입니다.

```js
window.toString(); // "[object Window]"
window.__proto__.__proto__.__proto__.__proto__ === Object.prototype; // true
```

를 통해서,

1. `window`는 객체다.
1. `window`의 최종 조상은 `Object.prototype`이다.

를 알 수 있습니다.

### 23.6.2: 전역 코드 평가
아래의 그림은 전역 코드 평가 과정에서 생성된 전역 실행 컨텍스트와 렉시컬 환경을 나타냅니다.
![a-23-9.png](/images/ch23/a-23-9.png)

#### 1. 전역 실행 컨텍스트 생성

전역 실행 컨텍스트를 생성하고, Stack에 push 합니다. Stack의 top-most element인 전역 실행 컨텍스트가 Running context가 됩니다.[^4]
[^4]: 책에서는 Stack의 top-most element가 Running context가 된다고 서술하고 있지만, 실제로는 Stack-like라서 `async`, generator, job queue 등이 사용되는 상황에서는 그렇지 않을수도 있습니다.

#### 2. 전역 렉시컬 환경 생성

전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩됩니다.

##### 2.1. 전역 환경 레코드 생성

ES6 이전에는 모든 전역 변수가 전역 객체의 프로퍼티이기 때문에 전역 객체가 전역 환경 레코드의 역할을 했지만,
ES6과 함께 등장한 `let`, `const`로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않고 개념적인 블록 내에 존재합니다.

`var`로 선언한 전역 변수와 `let`, `const`로 선언한 전역 변수를 구분하기 위해,
전역 환경 레코드는 객체 환경 레코드<sup>Object Environment Record</sup>와 선언적 환경 레코드<sup>Declarative Environment Record</sup>로 구성되어 있습니다.

**객체 환경 레코드**는 전역 객체를 `BindingObject`로 사용하여 `var`로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수를 전역 객체의 프로퍼티에 대한 바인딩으로 관리하며,
전역 객체에 이미 존재하는 표준 빌트인 객체들도 `BindingObject`를 통해 전역 식별자로 노출되게 됩니다.
**선언적 환경 레코드**는 `let`, `const`로 선언한 전역 변수를 관리합니다.

###### 2.1.1. 객체 환경 레코드 생성

객체 환경 레코드는 [23.6.1: 전역 객체 생성](#2361-전역-객체-생성)에서 생성된 전역 객체인 `BindingObject`와 연결됩니다.

전역 코드 평가 과정에서 `var`로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수는
전역 환경 레코드의 객체 환경 레코드에 연결된 `BindingObject`를 통해 전역 객체의 프로퍼티와 메서드가 됩니다.
이를 통해 전역 객체를 가리키는 식별자(`window`) 없이 `alert`, `console.log` 등의 빌트인 전역 함수를 호출할 수 있습니다.

- `var`를 통해 선언된 변수 `x`는 **선언 단계**와 **초기화 단계**가 **동시에** 진행됩니다.
  - 전역 코드 평가 시점에 _객체 환경 레코드에 바인딩된 `BindingObject`_ 를 통해 전역 객체에 변수 식별자를 키로 등록(선언)하고,
  - 암묵적으로 `undefined`를 바인딩(초기화)합니다.
  - 이로 인해, 추후 코드 실행 단계에서 선언 이전에 `x`를 참조할 수 있습니다.
    - 물론 선언문 이전에 참조하면 값은 `undefined`입니다.
  - 이게 변수 호이스팅이 발생하는 이유라고 할 수 있습니다.
- 함수 선언문으로 정의된 함수 `foo()`는 함수 이름과 동일한 이름의 식별잘르 _객체 환경 레코드에 바인딩된 `BindingObject`_ 를 통해 전역 객체에 키로 등록하고, 생성된 함수 객체를 즉시 할당합니다.
  - 이로 인해, 추후 코드 실행 단계에서 함수 선언문 이전에 함수를 참조할 수 있고, 호출할 수 있습니다.
  - 이게 함수 호이스팅입니다.

###### 2.1.2. 선언적 환경 레코드 생성

`let`과 `const`로 선언한 전역 변수는 선언 단계와 초기화 단계가 분리되어 진행됩니다.
이로 인해, 추후 코드 실행 단계에서 선언 이전에 `y`를 참조할 수 없습니다.
만약 선언문 이전(TDZ)에서 참조하면 참조 에러(ReferenceError)가 발생합니다.

`const`로 선언된 전역 변수 `y`는 전역 객체의 프로퍼티가 되지 않고 개념적인 블록(선언적 환경 레코드) 내에 존재하기 때문에, `window.y`와 같이 접근할 수 없습니다.

##### 2.2. `this` 바인딩

전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯에 `this`가 바인딩 됩니다.
일반적으로 전역 코드에서의 `this`는 전역 객체를 가리킵니다.

*전역 환경 레코드*를 구성하는 *객체 환경 레코드*와 *선언적 환경 레코드*에는 `this` 바인딩이 없고, *전역 환경 레코드*와 _함수 환경 레코드_([23.6.4. `foo` 함수 코드 평가](#2364-foo-함수-코드-평가))에만 존재합니다.

##### 2.3. 외부 렉시컬 환경에 대한 참조 결정

현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경(= 상위 스코프)를 가리키는 레퍼런스를 저장합니다.
전역 코드의 상위 스코프는 없으므로 `null`이 할당되고, 이는 전역 렉시컬 환경이 스코프 체인의 종점에 존재함을 의미합니다.

### 23.6.3: 전역 코드 실행

변수 할당문이 실행되면 전역 변수 `x`와 `y`에 값 `1`과 `2`를 할당합니다.
이후, 함수 `foo()`가 호출됩니다.

- **식별자 결정<sup>Identifier Resolution</sup>** : 어느 스코프의 식별자를 참조하면 되는지 결정
  - 식별자를 검색할 때는 실행 중인 실행 컨텍스트에서 검색하기 시작합니다.
  - 현재 컨텍스트에서 검색할 수 없으면, 상위 스코프(외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경)로 이동하여 식별자를 검색합니다.
  - 전역 렉시컬 환경은 스코프 체인의 종점이므로, 전역 렉시컬 환경에서 검색할 수 없는 식별자는 `ReferenceError`를 발생시킵니다.

### 23.6.4: `foo` 함수 코드 평가

`foo` 함수가 호출되면, 전역 코드의 실행을 일시 중단하고 `foo` 함수 내부로 코드의 제어권이 이동합니다. 이후, `foo` 함수의 코드 평가가 다음 순서와 같이 이루어집니다.

![a-23-17.png](/images/ch23/a-23-17.png)

#### 1. 함수 실행 컨텍스트 생성

`foo` 함수의 실행 컨텍스트를 생성합니다.

#### 2. 함수 렉시컬 환경 생성

`foo` 함수의 렉시컬 환경을 생성한 후, 실행 컨텍스트에 바인딩 합니다.
이후, 실행 컨텍스트가 Stack에 push 됩니다. `foo` 함수의 실행 컨텍스트가 Running context가 됩니다.

##### 2.1. 함수 환경 레코드 생성

함수 환경 레코드는 매개변수, `arguments` 객체, 함수 내부에서 선언한 지역 변수와 중첩 함수를 관리합니다.

##### 2.2. `this` 바인딩

함수 환경 레코드의 `[[ThisValue]]` 내부 슬롯에 `this`가 바인딩 됩니다.(어떤 객체가 `[[ThisValue]]` 내부 슬롯에 바인딩 되는지는 22장 참고)

`foo`는 일반 함수로 호출되었기 때문에, `this`는 전역 객체를 가리킵니다.

##### 2.3. 외부 렉시컬 환경에 대한 참조 결정

함수 정의가 평가된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경 참조가 할당 외부 렉시컬 환경에 대한 참조로 할당됩니다.
`foo` 함수의 경우 전역 렉시컬 환경의 참조가 할당됩니다.

지난 시간에 다뤘던 아래 내용 기억하시나요?

> 즉, **함수 상위 스코프는 언제나 자신이 정의된 전역 스코프다.**
> **함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정**된다. 함수 정의(함수 선언문 또는 함수 표현식)가 실행되어 생성된 **함수 객체**는 이렇게 결정된 상위 스코프를 기억한다. 함수가 호출될 때마다 상기할 필요가 있기 때문이다.

각 함수가 정의될 때, 현재 실행 중인 실행 컨텍스트의 렉시컬 환경(상위 Scope)의 정보를 `[[Environment]]`에 넣어두고, 나중에 이걸 기반으로 변수나 식별자를 찾습니다.
마찬가지로, 어떻게 `[[Environment]]`가 결정되고, 스코프 체인이 만들어지는지에 대한 더 자세한 내용은 [지난 스터디 PR의 코멘트](https://github.com/gdgoc-konkuk/25-26-study-js-deep-dive/pull/13#discussion_r2536463910)를 참고해보세요!

### 23.6.5: `foo` 함수 코드 실행

매개변수에 인수가 할당되고, 변수 할당문이 실행되어 지역변수 `x`와 `y`에 값이 할당됩니다.
이후, `bar()` 함수가 호출됩니다.

이때, 식별자 결정을 위해 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자 검색을 시작하고, 검색할 식별자가 없으면 상위 스코프로 이동하여 식별자를 검색합니다.

### 23.6.6: `bar` 함수 코드 평가

`bar` 함수가 호출되면, `foo` 함수의 실행을 일시 중단하고 `bar` 함수 내부로 코드의 제어권이 이동합니다. 이후, `bar` 함수의 코드 평가가 이루어집니다.
과정은 `foo` 함수 코드 평가와 동일합니다.

![a-23-23.png](/images/ch23/a-23-23.png)

### 23.6.7: `bar` 함수 코드 실행

마찬가지로, 매개변수에 인수가 할당되고, 변수 할당문이 실행되어 지역변수 `z`에 값이 할당됩니다.
이후, `console.log(a + b + x + y + z);`가 다음 순서로 실행됩니다.

#### 1. `console` 식별자 검색

`console` 식별자를 스코프 체인에서 검색합니다. 실행 중인 `bar` 함수의 렉시컬 환경에서 검색할 수 없으므로, 상위 스코프인 `foo` 함수의 렉시컬 환경 -> 전역 렉시컬 환경에서 검색합니다.
전역 렉시컬 환경은 *객체 환경 레코드*의 `BindingObject`를 통해 전역 객체에서 찾을 수 있습니다.

#### 2. `log` 메서드 검색

`console` 객체의 프로토타입 체인에서 `log` 메서드를 검색합니다.

#### 3. 표현식 `a + b + x + y + z`의 평가

표현식 `a + b + x + y + z`를 퍙기하개 위해 `a`, `b`, `x`, `y`, `z`를 스코프 체인에서 검색합니다.
이 과정에서 `a`는 `foo` 함수 렉시컬 환경, `b`는 `bar` 함수 렉시컬 환경, `x`와 `y`는 `foo` 함수 렉시컬 환경, `z`는 `bar` 함수 렉시컬 환경에서 찾을 수 있습니다.

#### 4. `console.log` 메서드 호출

`a + b + x + y + z`의 평가 결과인 42를 `console.log`의 인수로 전달하여 호출합니다.

### 23.6.8: `bar` 함수 코드 실행 종료

- Stack에서 `bar` 함수 실행 컨텍스트가 pop 되고, `foo` 함수의 실행 컨텍스트가 Running context가 됩니다.
- 이떄, `bar` 함수 실행 컨텍스트가 제거되어도 `bar` 함수 렉시컬 환경이 즉시 소멸되는 것은 아닙니다.
  - 렉시컬 환경은 실행 컨텍스트에 의해 참조는 되지만, 독립적인 객체이기 때문에, 더이상 참조되지 않을 때 가비지 컬렉터에 의해 메모리 공간이 회수되어 소멸합니다.
- 즉, `bar` 함수 렉시컬 환경을 다른 누군가 참조 중이라면 소멸되지 않습니다.

### 23.6.9: `foo` 함수 코드 실행 종료

Stack에서 `foo` 함수 실행 컨텍스트가 pop 되고, 전역 코드의 실행 컨텍스트가 Running context가 됩니다.

### 23.6.10: 전역 코드 실행 종료

더이상 실행할 코드가 없으므로, 전역 실행 컨텍스트가 Stack에서 pop 되어 빈 Stack이 됩니다.[^5]
[^5]: 그치만 브라우저 환경에서 전역 실행 컨텍스트가 pop되더라도 전역 렉시컬 환경과 Realm은 살아있고 이벤트 루프도 계속 돌아갑니다. 만약 비동기 콜백이나 이벤트가 발생하면 새로운 실행 컨텍스트가 스택에 push되어 실행됩니다.

</section>
## 23.7: 실행 컨텍스트와 블록 레벨 스코프
[15장](../15장%20let,%20const%20키워드와%20블록%20레벨%20스코프/A)에서 다뤘듯이, `var`로 선언된 변수는 함수 레벨 스코프를, `let` 또는 `const`로 선언된 변수는 블록 레벨 스코프를 갖습니다.

```js
let x = 1;

if (true) {
  let x = 10;
  console.log(x); // 10
}

console.log(x); // 1
```

위 예제에서, `if` 문의 코드 블록 내에서 `let`으로 선언된 변수가 존재하기 때문에, 새로운 블록 레벨 스코프를 생성해야 합니다.
이때 새로 생성된 `if` 문 코드 블럭을 위한 렉시컬 환경의 외부 렉시컬 환경 참조는 `if` 문 실행 이전 전역 렉시컬 환경을 가리킨다.

[실행 컨텍스트의 구조](#실행-컨텍스트의-구조)에서 다뤘던 _LexicalEnvironment_, *VariableEnvironment*와 관련이 있는데,
_LexicalEnvironment_, *VariableEnvironment*가 같은 값을 참조하다가, `let` 키워드로 선언된 변수가 선언되면 새로운 *LexicalEnvironment*가 생성되게 됩니다.

이러한 과정은 모든 블록문에 대해 적용됩니다. 만약 `for` 문의 변수 선언문에 `let` 키워드를 사용했다면, 코드 블록이 반복해서 실행될 때마다 새로운 렉시컬 환경이 생성됩니다.

## 각주
