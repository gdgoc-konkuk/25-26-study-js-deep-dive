# 6장 데이터 타입

자바스크립트의 모든 값은 반드시 데이터 타입을 가진다. 데이터 타입은 값의 종류를 구분하고, 그 값을 어떻게 해석하고 다룰 것인지를 결정하는 중요한 개념이다.

**자바스크립트의 데이터 타입 분류:**

| 구분      | 데이터 타입           | 설명                                              |
| --------- | --------------------- | ------------------------------------------------- |
|           | 숫자 타입 (number)    | 정수와 실수를 구분하지 않는 숫자 타입                      |
|           | 문자열 타입 (string)  | 텍스트 데이터                                            |
| 원시 타입 | 불리언 타입 (boolean) | 논리적 참(true)과 거짓(false)                       |
| (Primitive Type) | undefined 타입        | var 키워드로 선언된 변수에 암묵적으로 할당되는 값   |
|           | null 타입             | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 |
|           | 심벌 타입 (symbol)    | ES6에서 추가된 변경 불가능한 유일무이한 값                               |
| 객체 타입 (Object/Reference Type) |                       | 객체, 함수, 배열 등                                  |

개발자는 데이터 타입을 통해 값이 어떤 의미를 가지는지 명확히 표현해야 한다. 예를 들어, 숫자 `1`과 문자열 `'1'`은 외형은 유사하지만 완전히 다른 타입의 값이다.

## 6-1. 숫자 타입

자바스크립트는 C나 Java와 달리 하나의 숫자 타입만 존재한다.

**숫자 타입의 특징:**

- 정수, 실수, 부동소수점 등을 구분하지 않고 모두 **하나의 숫자 타입**으로 표현
- 내부적으로 **64비트 부동소수점 형식**(배정밀도 부동소수점, double-precision 64-bit floating-point format)을 따름
- 모든 수를 **실수로 처리**

```jsx
// 모두 동일한 number 타입
var integer = 10;
var double = 10.12;
var negative = -20;

// 자바스크립트는 모든 숫자를 실수로 처리
console.log(1 === 1.0);  // true
console.log(4 / 2);      // 2
console.log(3 / 2);      // 1.5 (정수 나눗셈이 아님)
```

**다양한 진법 표현:**

자바스크립트는 2진수, 8진수, 16진수 리터럴을 제공하지만, 모두 10진수로 해석된다.

```jsx
var binary = 0b01000001;  // 2진수 (0b 접두사)
var octal = 0o101;        // 8진수 (0o 접두사)
var hex = 0x41;           // 16진수 (0x 접두사)

console.log(binary);      // 65
console.log(octal);       // 65
console.log(hex);         // 65
console.log(binary === octal);  // true
console.log(octal === hex);     // true
```

**특별한 숫자 값:**

숫자 타입은 세 가지 특별한 값을 표현할 수 있다:

1. **Infinity**: 양의 무한대
2. **-Infinity**: 음의 무한대
3. **NaN** (Not-a-Number): 산술 연산 불가를 나타냄

```jsx
console.log(10 / 0);        // Infinity
console.log(10 / -0);       // -Infinity
console.log(1 * 'String');  // NaN
```

**주의사항:**

- 자바스크립트는 대소문자를 구분하므로 `NaN`을 정확히 표기해야 함 (`nan`, `Nan`, `NAN`은 모두 다른 식별자로 인식)
- `NaN`은 자기 자신과도 같지 않은 유일한 값 (`NaN === NaN`은 `false`)
- 값이 `NaN`인지 확인하려면 `Number.isNaN()` 메서드를 사용

```jsx
console.log(NaN === NaN);        // false
console.log(Number.isNaN(NaN));  // true
console.log(Number.isNaN(10));   // false
```

## 6-2. 문자열 타입

**문자열(String)** 타입은 텍스트 데이터를 나타내는 데 사용된다.

**문자열의 특징:**

- 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합
- 전 세계 대부분의 문자를 표현 가능
- 작은따옴표(`''`), 큰따옴표(`""`), 백틱(` `` `)으로 텍스트를 감싸서 표현
- **원시 타입**이며 **변경 불가능한 값(immutable value)**

**문자열 생성:**

```jsx
var string;
string = '문자열';    // 작은따옴표
string = "문자열";    // 큰따옴표
string = `문자열`;    // 백틱 (ES6)

// 따옴표 내부의 다른 종류 따옴표는 문자열로 인식
string = '작은따옴표로 감싼 문자열 내의 "큰따옴표"는 문자열로 인식된다.';
string = "큰따옴표로 감싼 문자열 내의 '작은따옴표'는 문자열로 인식된다.";
```

**따옴표의 필요성:**

따옴표를 사용하는 이유는 키워드나 식별자 같은 토큰과 문자열을 구분하기 위함이다.

```jsx
var string = hello;  // ReferenceError: hello is not defined
var string = 'hello';  // 'hello'라는 문자열
```

**문자열의 불변성:**

문자열은 생성된 후 변경할 수 없다. 이는 11장에서 더 자세히 다룬다.

```jsx
var str = 'Hello';
str[0] = 'W';  // 문자열은 변경 불가능 (에러는 발생하지 않지만 변경되지 않음)
console.log(str);  // 'Hello'
```

## 6-3. 템플릿 리터럴

**템플릿 리터럴(Template Literal)**은 ES6에서 도입된 새로운 문자열 표기법으로, 편리한 문자열 처리 기능을 제공한다.

**템플릿 리터럴의 특징:**

- 멀티라인 문자열 (Multi-line String)
- 표현식 삽입 (Expression Interpolation)
- 태그드 템플릿 (Tagged Template)

템플릿 리터럴은 백틱(` `` `)을 사용하며, 런타임에 일반 문자열로 변환되어 처리된다.

```jsx
var template = `Template literal`;
console.log(template);  // Template literal
```

### 6-3-1. 멀티라인 문자열

**일반 문자열의 줄바꿈:**

일반 문자열 내에서는 줄바꿈이 허용되지 않으며, 줄바꿈을 표현하려면 백슬래시(`\`)로 시작하는 이스케이프 시퀀스를 사용해야 한다.

**주요 이스케이프 시퀀스:**

| 이스케이프 시퀀스 | 의미 |
|------------------|------|
| `\n` | 개행 (Line Feed) |
| `\t` | 탭 (Tab) |
| `\\` | 백슬래시 |
| `\'` | 작은따옴표 |
| `\"` | 큰따옴표 |

```jsx
// 잘못된 예: 개행 직접 입력
var str = 'Hello
world.';  // SyntaxError: Invalid or unexpected token

// 올바른 예: 이스케이프 시퀀스 사용
var template = '<ul>\n\t<li><a href="#">Home</a></li>\n</ul>';
console.log(template);
// 출력:
// <ul>
// 	<li><a href="#">Home</a></li>
// </ul>
```

**템플릿 리터럴의 멀티라인:**

템플릿 리터럴을 사용하면 이스케이프 시퀀스 없이도 줄바꿈과 공백이 그대로 적용된다.

```jsx
var template = `<ul>
  <li><a href="#">Home</a></li>
</ul>`;

console.log(template);
// 출력:
// <ul>
//   <li><a href="#">Home</a></li>
// </ul>
```

### 6-3-2. 표현식 삽입

**일반 문자열의 연결:**

일반 문자열에서는 문자열 연결 연산자 `+`를 사용하여 여러 문자열을 연결한다.

```jsx
var first = 'Ung-mo';
var last = 'Lee';

// ES5: 문자열 연결
console.log('My name is ' + first + ' ' + last + '.');
// My name is Ung-mo Lee.
```

**템플릿 리터럴의 표현식 삽입:**

템플릿 리터럴 내에서는 `${}`를 사용하여 표현식을 삽입할 수 있다. 이는 가독성과 편의성을 크게 향상시킨다.

```jsx
var first = 'Ung-mo';
var last = 'Lee';

// ES6: 표현식 삽입
console.log(`My name is ${first} ${last}.`);
// My name is Ung-mo Lee.
```

**표현식 삽입의 활용:**

```jsx
console.log(`1 + 2 = ${1 + 2}`);  // 1 + 2 = 3
```

**주의사항:**

표현식 삽입은 반드시 템플릿 리터럴 내에서 사용해야 한다. 일반 문자열에서 사용하면 문자열로 취급된다.

```jsx
console.log(`1 + 2 = ${1 + 2}`);  // 1 + 2 = 3 (표현식 평가)
console.log('1 + 2 = ${1 + 2}');  // 1 + 2 = ${1 + 2} (문자열 그대로)
```

## 6-4. 불리언 타입

**불리언(Boolean)** 타입은 논리적 참과 거짓을 나타내는 `true`와 `false` 두 가지 값만을 가진다.

```jsx
var foo = true;
console.log(foo);  // true

foo = false;
console.log(foo);  // false
```

불리언 타입은 주로 조건문에서 프로그램의 흐름을 제어하는 데 사용된다.

```jsx
var isAdult = true;

if (isAdult) {
  console.log('성인입니다.');
} else {
  console.log('미성년자입니다.');
}
```

## 6-5. undefined 타입

**undefined** 타입의 값은 `undefined`가 유일하다.

**undefined의 의미와 용도:**

- `undefined`는 "값이 할당된 적이 없음"을 나타내는 값
- `var` 키워드로 선언한 변수는 암묵적으로 `undefined`로 초기화됨
- 개발자가 의도적으로 변수에 할당하는 것은 권장되지 않음

```jsx
var foo;
console.log(foo);  // undefined
```

**변수 초기화 과정:**

1. 변수 선언 시 메모리 공간 확보
2. 자바스크립트 엔진이 암묵적으로 `undefined`로 초기화
3. 첫 번째 할당이 이루어질 때까지 `undefined` 상태 유지

**undefined vs null:**

- `undefined`: 자바스크립트 엔진이 변수를 초기화할 때 사용
- `null`: 개발자가 의도적으로 "값이 없음"을 명시할 때 사용

따라서 개발자가 의도적으로 변수에 값이 없음을 표현하고 싶다면 `undefined`가 아닌 `null`을 사용해야 한다.

```jsx
var foo = null;  // 의도적으로 값이 없음을 명시
```

## 6-6. null 타입

**null** 타입의 값은 `null`이 유일하다.

**null의 의미와 용도:**

- `null`은 "값이 없음"을 의도적으로 명시할 때 사용
- 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미
- 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 역할

```jsx
var foo = 'Lee';

// foo가 더 이상 'Lee'를 참조하지 않도록 설정
// 이전 값에 대한 참조가 제거되어 가비지 컬렉션 대상이 됨
foo = null;
```

**null의 사용 예:**

함수가 유효한 값을 반환할 수 없는 경우 명시적으로 `null`을 반환하기도 한다.

```jsx
var element = document.querySelector('.myClass');
// HTML 문서에 .myClass 클래스를 갖는 요소가 없으면 null 반환
console.log(element);  // null
```

**주의사항:**

- 자바스크립트는 대소문자를 구분하므로 `null`을 정확히 표기해야 함
- `Null`, `NULL` 등은 다른 식별자로 인식됨

## 6-7. 심벌 타입

**심벌(Symbol)** 타입은 ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다.

**심벌의 특징:**

- 다른 값과 **중복되지 않는 유일무이한 값**
- 주로 객체의 유일한 프로퍼티 키를 만들기 위해 사용
- 외부에 노출되지 않아 충돌 위험이 없음

**심벌 값 생성:**

심벌은 `Symbol` 함수를 호출하여 생성한다.

```jsx
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key);  // symbol

// 객체 생성
var obj = {};

// 심벌을 프로퍼티 키로 사용
obj[key] = 'value';
console.log(obj[key]);  // value
```

**심벌의 활용:**

```jsx
// 서로 다른 심벌은 유일무이함
var symbol1 = Symbol('mySymbol');
var symbol2 = Symbol('mySymbol');

console.log(symbol1 === symbol2);  // false

// 객체의 프로퍼티 키 충돌 방지
var obj = {
  [symbol1]: 'value1',
  [symbol2]: 'value2'
};

console.log(obj[symbol1]);  // value1
console.log(obj[symbol2]);  // value2
```

심벌에 대한 자세한 내용은 33장에서 다룬다.

## 6-8. 객체 타입

지금까지 살펴본 6가지 타입(숫자, 문자열, 불리언, undefined, null, 심벌) 이외의 값은 모두 **객체 타입**이다.

**중요한 개념:**

자바스크립트는 **객체 기반 언어**이며, **자바스크립트를 이루는 거의 모든 것이 객체**이다.

- 배열, 함수, 정규 표현식 등도 모두 객체
- 원시 타입 값을 제외한 나머지는 모두 객체 타입

객체 타입은 11장에서 자세히 다룬다.

```jsx
var obj = { name: 'Lee', age: 20 };  // 객체
var arr = [1, 2, 3];                 // 배열 (객체)
var func = function() {};            // 함수 (객체)
```

## 6-9. 데이터 타입의 필요성

데이터 타입이 필요한 이유는 무엇인가? 데이터 타입은 다음 세 가지 측면에서 필수적이다.

### 6-9-1. 메모리 공간의 확보

값을 저장할 때 **확보해야 하는 메모리 공간의 크기를 결정**하기 위해 데이터 타입이 필요하다.

예를 들어, 다음 코드를 살펴보자:

```jsx
var score = 100;
```

**값의 저장 과정:**

1. 리터럴 `100`을 숫자 타입의 값으로 해석
2. 숫자 타입은 8바이트(64비트)의 메모리 공간이 필요함을 인식
3. 8바이트의 메모리 공간을 확보
4. 100을 2진수로 변환하여 해당 메모리 공간에 저장

만약 데이터 타입이 없다면, 얼마만큼의 메모리를 확보해야 할지 알 수 없어 값을 올바르게 저장할 수 없다.

### 6-9-2. 메모리 공간의 참조

값을 참조할 때 **한 번에 읽어 들여야 할 메모리 공간의 크기를 결정**하기 위해 데이터 타입이 필요하다.

```jsx
var score = 100;
console.log(score);  // 변수 score 참조
```

**값의 참조 과정:**

1. 변수 `score`의 메모리 주소 확인
2. 변수에 저장된 값의 타입(숫자 타입) 확인
3. 숫자 타입은 8바이트이므로, 8바이트만큼 메모리에서 읽어들임

만약 4바이트만 읽는다면 값이 잘리고, 16바이트를 읽는다면 다른 값까지 읽어버리는 문제가 발생한다.

### 6-9-3. 값의 해석

메모리에서 읽어 들인 2진수를 **어떻게 해석할지 결정**하기 위해 데이터 타입이 필요하다.

메모리에 저장된 값은 모두 2진수 비트의 나열이다. 예를 들어, `0100 0001`이라는 2진수는 다음과 같이 다양하게 해석될 수 있다:

- 숫자로 해석: 65
- 문자로 해석: 'A'

데이터 타입에 따라 동일한 2진수도 다르게 해석된다.

**심벌 테이블:**

컴파일러 또는 인터프리터는 **심벌 테이블(Symbol Table)**이라는 자료 구조를 통해 식별자를 키로 하여 다음 정보를 관리한다:

- 바인딩된 값의 메모리 주소
- 데이터 타입
- 스코프

## 6-10. 동적 타이핑

프로그래밍 언어는 변수의 타입을 결정하는 방식에 따라 정적 타입 언어와 동적 타입 언어로 구분된다.

### 6-10-1. 정적 타입 언어와 동적 타입 언어

**정적 타입 언어 (Static Type Language)**

대표적인 예: C, C++, Java, Kotlin, Go, Haskell, Rust, Scala

**특징:**

- **명시적 타입 선언**: 변수를 선언할 때 데이터 타입을 사전에 선언해야 함
- **타입 변경 불가**: 선언한 타입 이외의 값을 할당할 수 없음
- **컴파일 타임 타입 체크**: 컴파일 시점에 타입 체크 수행
- **타입 안정성**: 타입의 일관성을 강제하여 안정적인 코드 구현 가능

```c
// C 언어 예시
char c;      // 1바이트 정수 타입 (-128 ~ 127)
int num;     // 4바이트 정수 타입 (-2,147,483,648 ~ 2,147,483,647)

c = 100;     // OK
c = "Hello"; // 컴파일 에러: 타입 불일치
```

**동적 타입 언어 (Dynamic Type Language)**

대표적인 예: JavaScript, Python, PHP, Ruby, Lisp, Perl

**특징:**

- **타입 선언 불필요**: 변수 선언 시 타입을 선언하지 않음
- **자유로운 할당**: 어떤 타입의 값이든 자유롭게 할당 가능
- **동적 타입 결정**: 할당된 값에 의해 변수의 타입이 동적으로 결정됨
- **런타임 타입 결정**: 실행 시점에 타입 결정

```jsx
var foo;
console.log(typeof foo);  // undefined

foo = 3;
console.log(typeof foo);  // number

foo = 'Hello';
console.log(typeof foo);  // string

foo = true;
console.log(typeof foo);  // boolean

foo = null;
console.log(typeof foo);  // object (자바스크립트의 버그)

foo = Symbol();
console.log(typeof foo);  // symbol

foo = {};
console.log(typeof foo);  // object

foo = [];
console.log(typeof foo);  // object

foo = function() {};
console.log(typeof foo);  // function
```

**typeof 연산자:**

`typeof` 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.

**중요한 개념:**

- 자바스크립트에서 **변수는 타입을 갖지 않는다**
- **값은 타입을 가진다**
- 변수에 할당된 값의 타입에 따라 변수의 타입이 동적으로 결정된다

이를 **동적 타이핑(Dynamic Typing)**이라고 하며, 자바스크립트를 **동적 타입 언어**라고 부르는 이유이다.

### 6-10-2. 동적 타입 언어의 장단점

**장점 (유연성):**

- 변수 선언이 간편함
- 타입에 대해 신경 쓸 필요가 적음
- 빠른 프로토타이핑 가능

**단점 (신뢰성 저하):**

- 변수의 타입이 언제든지 변경될 수 있어 값 추적이 어려움
- 타입을 확인하기 전까지 변수의 타입을 확신할 수 없음
- 암묵적 타입 변환으로 인한 예측 불가능한 동작
- 복잡한 프로그램에서 런타임 에러 발생 가능성 증가

**동적 타입 언어 사용 시 주의사항:**

1. **변수 사용 최소화**: 변수는 꼭 필요한 경우에만 제한적으로 사용
2. **스코프 최소화**: 변수의 유효 범위(스코프)를 최대한 좁게 만들어 부작용 억제
3. **전역 변수 지양**: 전역 변수는 최대한 사용하지 않음
4. **상수 활용**: 변경이 필요 없는 값은 `const` 키워드를 사용
5. **의미 있는 네이밍**: 변수 이름으로 목적과 의미를 명확히 전달

**핵심 원칙:**

> "동작하는 코드도 중요하지만, **가독성이 좋은 코드가 좋은 코드**다."

코드는 작성하는 시간보다 읽히는 시간이 훨씬 길다. 따라서 가독성과 유지보수성을 최우선으로 고려해야 한다.

---

## 학습 점검 문제

### 문제 1: 데이터 타입 구분

다음 값들의 데이터 타입을 `typeof` 연산자로 확인했을 때의 결과를 쓰시오.

```jsx
A. 42
B. '42'
C. true
D. undefined
E. null
F. Symbol('key')
G. { name: 'Lee' }
H. [1, 2, 3]
I. function() {}
```

<details>
<summary>해답 보기</summary>

```jsx
A. typeof 42                  // 'number'
B. typeof '42'                // 'string'
C. typeof true                // 'boolean'
D. typeof undefined           // 'undefined'
E. typeof null                // 'object' (자바스크립트의 버그)
F. typeof Symbol('key')       // 'symbol'
G. typeof { name: 'Lee' }     // 'object'
H. typeof [1, 2, 3]           // 'object'
I. typeof function() {}       // 'function'
```

**주의:**
- `null`의 typeof 결과가 'object'인 것은 자바스크립트 초기 버전의 버그
- 배열도 객체이므로 'object' 반환
- 함수는 'function' 반환 (특별 취급)
</details>

### 문제 2: 숫자 타입의 특징

다음 코드의 실행 결과를 예측하시오.

```jsx
console.log(1 === 1.0);
console.log(0.1 + 0.2 === 0.3);
console.log(10 / 0);
console.log(-10 / 0);
console.log(0 / 0);
```

<details>
<summary>해답 보기</summary>

```jsx
console.log(1 === 1.0);          // true (모든 수를 실수로 처리)
console.log(0.1 + 0.2 === 0.3);  // false (부동소수점 연산의 한계)
console.log(10 / 0);             // Infinity
console.log(-10 / 0);            // -Infinity
console.log(0 / 0);              // NaN
```

**설명:**
- `0.1 + 0.2`는 정확히 `0.3`이 아니라 `0.30000000000000004`
- 이는 2진법으로 변환 시 무한소수가 되는 일부 10진수의 특성 때문
- 부동소수점 연산 비교 시 주의 필요
</details>

### 문제 3: 템플릿 리터럴 활용

다음 변수들을 사용하여 "My name is John Doe and I am 25 years old." 문자열을 템플릿 리터럴로 생성하시오.

```jsx
var firstName = 'John';
var lastName = 'Doe';
var age = 25;
```

<details>
<summary>해답 보기</summary>

```jsx
var message = `My name is ${firstName} ${lastName} and I am ${age} years old.`;
console.log(message);
// My name is John Doe and I am 25 years old.

// 표현식 삽입 활용
var message2 = `My name is ${firstName} ${lastName} and I am ${age + 1} years old next year.`;
console.log(message2);
// My name is John Doe and I am 26 years old next year.
```
</details>

### 문제 4: undefined vs null

다음 중 올바른 사용법을 고르고, 그 이유를 설명하시오.

```jsx
// A
var foo;
console.log(foo);  // undefined

// B
var bar = undefined;

// C
var baz = null;
```

<details>
<summary>해답 보기</summary>

**올바른 사용:**

- A: 올바름 - 변수 선언 시 자바스크립트 엔진이 자동으로 undefined 할당
- C: 올바름 - 의도적으로 값이 없음을 명시할 때 null 사용

**권장하지 않는 사용:**

- B: 비권장 - 개발자가 의도적으로 undefined를 할당하는 것은 본래 취지에 맞지 않음

**이유:**
- `undefined`는 자바스크립트 엔진이 초기화에 사용하는 값
- 개발자가 명시적으로 "값이 없음"을 나타내려면 `null` 사용
- 이를 통해 변수의 상태를 명확히 구분 가능
  - `undefined`: 초기화되지 않음 (엔진 관리)
  - `null`: 의도적으로 값이 없음 (개발자 의도)
</details>

### 문제 5: 동적 타이핑의 문제

다음 코드의 문제점을 찾고 개선 방안을 제시하시오.

```jsx
var data = '100';
console.log(data + 50);    // 기대: 150
console.log(data - 50);    // 기대: 50
```

<details>
<summary>해답 보기</summary>

**문제점:**

```jsx
var data = '100';
console.log(data + 50);    // '10050' (문자열 연결)
console.log(data - 50);    // 50 (암묵적 타입 변환)
```

- `+` 연산자는 문자열 연결 연산자로 동작
- `-` 연산자는 산술 연산자로 동작하여 문자열을 숫자로 변환

**개선 방안:**

```jsx
// 방법 1: 명시적 타입 변환
var data = '100';
console.log(Number(data) + 50);    // 150
console.log(Number(data) - 50);    // 50

// 방법 2: 처음부터 올바른 타입 사용
var data = 100;
console.log(data + 50);    // 150
console.log(data - 50);    // 50

// 방법 3: parseInt 사용 (정수 변환)
var data = '100';
console.log(parseInt(data) + 50);    // 150
```

**교훈:**
- 동적 타이핑의 편리함에 의존하지 말 것
- 명시적 타입 변환을 통해 의도를 명확히 할 것
- 변수의 타입을 일관되게 유지할 것
</details>

### 문제 6: 심벌의 활용

다음 객체에 외부에 노출되지 않는 비공개 프로퍼티를 추가하시오.

```jsx
var user = {
  name: 'Lee',
  age: 20
};
```

<details>
<summary>해답 보기</summary>

```jsx
// 심벌을 사용한 비공개 프로퍼티
var privateKey = Symbol('privateData');

var user = {
  name: 'Lee',
  age: 20,
  [privateKey]: 'secret information'
};

console.log(user.name);           // 'Lee'
console.log(user[privateKey]);    // 'secret information'
console.log(Object.keys(user));   // ['name', 'age'] (심벌 키는 제외됨)

// 일반적인 프로퍼티 순회에서 심벌은 제외됨
for (var key in user) {
  console.log(key);  // 'name', 'age'만 출력
}

// 심벌로 생성한 프로퍼티 키는 외부에서 접근하기 어려움
// 다른 심벌 값으로는 접근 불가
var anotherKey = Symbol('privateData');
console.log(user[anotherKey]);    // undefined
```

**활용 사례:**
- 프레임워크나 라이브러리 내부 구현에서 사용
- 이름 충돌을 방지해야 하는 상황
- Well-known symbols (내장 심벌): `Symbol.iterator`, `Symbol.toStringTag` 등
</details>

---

## 심화 학습: 타입 변환과 단축 평가

자바스크립트는 동적 타입 언어로서 다양한 타입 변환이 발생한다.

**명시적 타입 변환 (Explicit Coercion):**

개발자가 의도적으로 타입을 변환하는 것

```jsx
var num = 10;
var str = String(num);       // '10'
var bool = Boolean(num);     // true

var str2 = '100';
var num2 = Number(str2);     // 100
var num3 = parseInt(str2);   // 100
```

**암묵적 타입 변환 (Implicit Coercion):**

자바스크립트 엔진이 자동으로 타입을 변환하는 것

```jsx
var x = 10;

// 문자열 연결 연산자
var str = x + '';            // '10' (숫자 → 문자열)

// 산술 연산자
var num = '10' - 0;          // 10 (문자열 → 숫자)
var num2 = '10' * 1;         // 10 (문자열 → 숫자)

// 불리언 컨텍스트
if ('hello') {               // 'hello' → true
  console.log('참');
}

if (0) {                     // 0 → false
  console.log('거짓');
}
```

**Truthy와 Falsy 값:**

자바스크립트는 불리언 타입이 아닌 값을 불리언 컨텍스트에서 사용할 때 Truthy 또는 Falsy 값으로 평가한다.

**Falsy 값 (거짓으로 평가되는 값):**
- `false`
- `0`, `-0`
- `''` (빈 문자열)
- `null`
- `undefined`
- `NaN`

**Truthy 값:**
- Falsy 값을 제외한 모든 값

```jsx
// Falsy 값
if (false) { }      // 실행 안 됨
if (0) { }          // 실행 안 됨
if ('') { }         // 실행 안 됨
if (null) { }       // 실행 안 됨
if (undefined) { } // 실행 안 됨
if (NaN) { }        // 실행 안 됨

// Truthy 값
if (true) { }       // 실행됨
if (1) { }          // 실행됨
if ('hello') { }    // 실행됨
if ({}) { }         // 실행됨 (빈 객체도 Truthy)
if ([]) { }         // 실행됨 (빈 배열도 Truthy)
```

타입 변환과 단축 평가에 대한 자세한 내용은 9장에서 다룬다.

## 심화 학습: 데이터 타입과 메모리

**원시 타입과 객체 타입의 메모리 관리:**

- **원시 타입**: 값 자체가 변수에 저장됨 (값에 의한 전달)
- **객체 타입**: 참조값(메모리 주소)이 변수에 저장됨 (참조에 의한 전달)

```jsx
// 원시 타입
var num1 = 100;
var num2 = num1;  // 값 복사
num2 = 200;

console.log(num1);  // 100 (변경되지 않음)
console.log(num2);  // 200

// 객체 타입
var obj1 = { value: 100 };
var obj2 = obj1;  // 참조값 복사
obj2.value = 200;

console.log(obj1.value);  // 200 (함께 변경됨)
console.log(obj2.value);  // 200
```

이러한 차이는 11장에서 더 자세히 다룬다.
