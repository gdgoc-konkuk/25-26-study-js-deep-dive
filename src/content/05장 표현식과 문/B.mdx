# 5장 표현식과 문

본 장에서는 프로그래밍의 기본 구성 요소인 표현식과 문에 대해 학습한다. 이들 개념을 정확히 이해하는 것은 자바스크립트뿐만 아니라 프로그래밍 전반의 이해도를 높이는 데 필수적이다.

용어의 정의를 명확히 하는 것은 개발자 간의 효과적인 의사소통을 위해 중요하다. 하지만 지나치게 학술적인 접근보다는, 실무에서 이들을 어떻게 구분하고 활용하는지에 초점을 맞추어 학습하는 것이 효율적이다.

## 5-1. 값의 본질

**값(Value)**이란 **표현식(Expression)**이 **평가(Evaluate)**되어 생성된 결과물이다.

여기서 **평가**는 표현식을 해석하여 값을 생성하거나 참조하는 과정을 의미한다. 즉, 표현식을 계산하여 하나의 값으로 귀결시키는 것이다.

```jsx
10 + 20;
// '10 + 20'이라는 표현식이 평가되어 숫자 값 30을 생성
```

**값의 중요한 특성:**

- 변수에 할당되는 것은 항상 **값**이다.
- 모든 값은 데이터 타입을 가지며, 타입에 따라 다르게 해석된다.
- 값은 프로그램에서 조작할 수 있는 최소 단위의 데이터이다.

```jsx
var sum = 10 + 20;  // 변수 sum에 할당되는 것은 값 30
```

## 5-2. 리터럴

값을 생성하는 방법은 다양하며, 그 중 가장 기본적이고 직관적인 방법이 **리터럴**을 사용하는 것이다.

**리터럴(Literal)**은 사람이 이해할 수 있는 문자(숫자, 알파벳, 한글 등) 또는 약속된 기호(`''`, `""`, `[]`, `{}`, `//` 등)를 사용하여 값을 표기하는 방법이다.

리터럴은 자바스크립트 엔진에 의해 평가되어 값을 생성한다.

**리터럴의 평가 과정:**

```jsx
3;  // 숫자 리터럴
```

![JS 엔진이 주어진 리터럴을 평가해서 메모리에 저장되는 값을 생성한다.](/images/ch05/ch5_a1.png)

1. 개발자가 숫자 리터럴 `3`을 작성
2. 자바스크립트 엔진이 런타임에 리터럴을 평가
3. 숫자 값 3이 생성되어 메모리에 저장

**자바스크립트의 다양한 리터럴:**

![a2.png](/images/ch05/ch5_a2.png)

| 리터럴 종류 | 예시 | 생성되는 값 |
|-----------|------|-----------|
| 정수 리터럴 | `100` | 정수 100 |
| 부동소수점 리터럴 | `10.5` | 실수 10.5 |
| 2진수 리터럴 | `0b01000001` | 정수 65 |
| 8진수 리터럴 | `0o101` | 정수 65 |
| 16진수 리터럴 | `0x41` | 정수 65 |
| 문자열 리터럴 | `'Hello'`, `"World"` | 문자열 |
| 불리언 리터럴 | `true`, `false` | 불리언 값 |
| null 리터럴 | `null` | null |
| undefined 리터럴 | `undefined` | undefined |
| 객체 리터럴 | `{ name: 'Lee' }` | 객체 |
| 배열 리터럴 | `[1, 2, 3]` | 배열 |
| 함수 리터럴 | `function() {}` | 함수 객체 |
| 정규 표현식 리터럴 | `/ab+c/` | 정규 표현식 |

## 5-3. 표현식

**표현식(Expression)**은 값으로 평가될 수 있는 문(statement)이다.

```jsx
var score = 100;  // 100은 표현식
```

**표현식의 구성:**

표현식은 다음 요소들의 조합으로 이루어질 수 있다:

- 리터럴
- 식별자 (변수, 함수 등의 이름)
- 연산자
- 함수 호출

**표현식의 핵심:**

- 표현식이 평가되면 **새로운 값을 생성**하거나 **기존 값을 참조**한다.
- 리터럴도 값으로 평가되므로, **리터럴은 곧 표현식**이다.
- 값이 위치할 수 있는 곳에는 표현식도 위치할 수 있다.

**다양한 표현식의 예:**

```jsx
// 리터럴 표현식
10
'Hello'

// 식별자 표현식 (선언이 이미 존재한다고 가정)
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
sum !== 10

// 함수/메서드 호출 표현식
square()
person.getName()
```

모든 표현식은 값으로 평가되며, 따라서 표현식과 값은 동등한 관계, 즉 **동치(Equivalent)**이다.

```jsx
var x = 1 + 2;
// 1 + 2는 표현식이며, 3이라는 값으로 평가된다.
// 표현식 1 + 2와 값 3은 동치이므로, 다음과 같이도 표현 가능하다:
var x = 3;
```

## 5-4. 문

**문(Statement)**은 프로그램을 구성하는 기본 단위이자 **최소 실행 단위**이다.

문의 역할은 명령을 수행하는 것이다. 프로그램은 문들의 집합으로 이루어지며, 프로그래밍이란 문을 작성하고 순서에 맞게 나열하는 것이다.

### 5-4-1. 문의 구성: 토큰

문은 여러 **토큰(Token)**으로 구성된다.

**토큰**은 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.

![a3.png](/images/ch05/ch5_a3.png)

토큰의 예:
- 키워드 (`var`, `let`, `const`, `if`, `for` 등)
- 식별자 (변수명, 함수명 등)
- 연산자 (`+`, `-`, `=`, `===` 등)
- 리터럴 (숫자, 문자열 등)
- 세미콜론 (`;`), 마침표 (`.`), 쉼표 (`,`) 등의 특수 기호

```jsx
var sum = 1 + 2;
```

위 문은 다음 토큰들로 구성된다:
- `var` (키워드)
- `sum` (식별자)
- `=` (할당 연산자)
- `1` (숫자 리터럴)
- `+` (산술 연산자)
- `2` (숫자 리터럴)
- `;` (세미콜론)

### 5-4-2. 문의 분류

문은 수행하는 역할에 따라 다음과 같이 분류할 수 있다:

**1. 선언문 (Declaration Statement)**

변수나 함수를 선언한다.

```jsx
var x;                    // 변수 선언문
function foo() {}         // 함수 선언문
```

**2. 할당문 (Assignment Statement)**

값을 할당한다.

```jsx
x = 5;                    // 할당문
```

**3. 조건문 (Conditional Statement)**

조건에 따라 코드 블록의 실행을 결정한다.

```jsx
if (x > 1) {
  console.log(x);
}
```

**4. 반복문 (Loop Statement)**

특정 코드 블록을 반복 실행한다.

```jsx
for (var i = 0; i < 2; i++) {
  console.log(i);
}
```

**5. 함수 호출문, 제어문 등**

```jsx
console.log('Hello');     // 함수 호출문
break;                    // break 문
continue;                 // continue 문
return x;                 // return 문
```

## 5-5. 세미콜론과 세미콜론 자동 삽입

**세미콜론(`;`)**은 문의 종료를 나타낸다.

자바스크립트 엔진은 세미콜론을 기준으로 문이 종료된 위치를 파악하고, 순차적으로 하나씩 문을 실행한다.

**세미콜론 사용 원칙:**

```jsx
var x = 5;                // 세미콜론으로 문의 종료 표시
var y = 10;
```

**주의사항: 코드 블록의 경우**

중괄호 `{}`로 묶인 코드 블록(블록문) 뒤에는 세미콜론을 붙이지 않는다.

```jsx
if (x > 0) {
  console.log(x);
}  // 세미콜론 불필요

function foo() {
  return x;
}  // 세미콜론 불필요

for (var i = 0; i < 10; i++) {
  console.log(i);
}  // 세미콜론 불필요
```

코드 블록은 **자체 종결성(Self Closing)**을 가지고 있어, 블록의 끝이 곧 문의 종료를 의미하기 때문이다.

### 5-5-1. 세미콜론 자동 삽입 기능

자바스크립트 엔진은 **ASI(Automatic Semicolon Insertion)** 기능을 제공한다. 이는 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 자동으로 세미콜론을 삽입하는 기능이다.

```jsx
var x = 5
var y = 10
console.log(x + y)
// ASI에 의해 다음과 같이 해석됨:
// var x = 5;
// var y = 10;
// console.log(x + y);
```

**세미콜론 사용에 대한 논쟁:**

- **세미콜론 사용 찬성**: 명시적 표현으로 코드의 의도를 명확히 하고, ASI의 예측 불가능한 동작을 방지
- **세미콜론 사용 반대**: ASI를 신뢰하고 코드를 간결하게 유지

그러나 ASI가 항상 개발자의 의도대로 동작한다고 보장할 수 없으므로, **세미콜론을 명시적으로 사용하는 것이 안전하고 권장된다**.

**ASI의 예측 불가능한 동작 예시:**

```jsx
function foo() {
  return
    {
      bar: 'baz'
    }
}
console.log(foo());  // undefined (의도: 객체 반환)

// ASI가 다음과 같이 해석:
// return;
// {
//   bar: 'baz'
// }
```

## 5-6. 표현식인 문과 표현식이 아닌 문

문과 표현식의 차이를 명확히 구분하는 것은 중요하다. 이 둘을 구분하는 가장 명확한 기준은 **변수에 할당 가능한가**이다.

**표현식인 문 (Expression Statement)**

값으로 평가될 수 있으므로 변수에 **할당 가능**하다.

```jsx
var x;            // 변수 선언문은 표현식이 아닌 문

// 표현식인 문들:
x = 1 + 2;        // 할당문은 표현식이면서 문이다
var result = (x = 100);  // 할당문의 결과를 변수에 할당 가능
```

**표현식이 아닌 문 (Non-Expression Statement)**

값으로 평가될 수 없으므로 변수에 **할당 불가능**하다.

```jsx
var foo = var x;  // SyntaxError: Unexpected token var
// 변수 선언문은 값으로 평가되지 않으므로 표현식이 아니다
```

### 5-6-1. 크롬 개발자 도구에서의 완료 값

크롬 개발자 도구의 콘솔에서 문을 실행하면 **완료 값(Completion Value)**이 출력된다.

```jsx
var x = 10;       // 콘솔 출력: undefined (표현식이 아닌 문)
```

표현식이 아닌 문은 언제나 `undefined`를 완료 값으로 가진다. 완료 값은 값이 아니므로 변수에 할당하거나 참조할 수 없다.

```jsx
x = 100;          // 콘솔 출력: 100 (표현식인 문)
```

표현식인 문은 평가된 값을 완료 값으로 가진다.

### 5-6-2. 구분 방법 정리

**표현식이 아닌 문:**

```jsx
var x;                    // 선언문
if (x > 0) { }           // 조건문
for (var i = 0; i < 5; i++) { }  // 반복문
```

**표현식인 문:**

```jsx
1;                       // 리터럴 표현식
1 + 2;                   // 연산자 표현식
x = 1 + 2;               // 할당 표현식
foo();                   // 함수 호출 표현식
```

**검증 방법:**

변수에 할당해보면 구분할 수 있다.

```jsx
// 표현식인 문은 할당 가능
var result1 = 1 + 2;           // 가능
var result2 = x = 100;         // 가능
var result3 = foo();           // 가능

// 표현식이 아닌 문은 할당 불가능
var result4 = var y;           // SyntaxError
var result5 = if (true) { };   // SyntaxError
```

---

## 학습 점검 문제

### 문제 1: 표현식 구분하기

다음 중 표현식이 **아닌** 것을 모두 고르시오.

```jsx
A. 100
B. var total;
C. total = 50 + 50;
D. function add() {}
E. 10 > 5
F. for (var i = 0; i < 10; i++) {}
```

<details>
<summary>해답 보기</summary>

**정답: B, D, F**

- A (표현식): 숫자 리터럴, 100으로 평가됨
- B (표현식 아님): 변수 선언문, 값으로 평가되지 않음
- C (표현식): 할당문, 할당된 값으로 평가됨
- D (표현식 아님): 함수 선언문 (단, 함수 표현식은 표현식임)
- E (표현식): 비교 연산자 표현식, true 또는 false로 평가됨
- F (표현식 아님): 반복문, 값으로 평가되지 않음
</details>

### 문제 2: 리터럴의 이해

다음 코드의 실행 결과를 예측하시오.

```jsx
var a = 10;
var b = 10.0;
var c = 0b1010;
var d = 0o12;
var e = 0xA;

console.log(a === b);
console.log(a === c);
console.log(c === d);
console.log(d === e);
```

<details>
<summary>해답 보기</summary>

**실행 결과:** 모두 `true`

**이유:**
- 자바스크립트는 정수와 실수를 구분하지 않고 모두 실수로 처리
- 다양한 진법의 숫자 리터럴은 모두 10진수로 해석됨
- 2진수 `0b1010`, 8진수 `0o12`, 16진수 `0xA`는 모두 10진수 10과 같음
</details>

### 문제 3: 표현식과 문의 구분

다음 코드에서 에러가 발생하는 라인을 찾고 이유를 설명하시오.

```jsx
var x = 10;           // 1번 줄
var y = x = 20;       // 2번 줄
var z = var w = 30;   // 3번 줄
var result = (x > y); // 4번 줄
```

<details>
<summary>해답 보기</summary>

**에러 발생 라인:** 3번 줄

**이유:**
- `var w = 30`은 변수 선언문으로, 표현식이 아닌 문
- 표현식이 아닌 문은 값으로 평가되지 않으므로 변수에 할당 불가능
- 1번: 정상 (리터럴 표현식 10을 할당)
- 2번: 정상 (할당문 `x = 20`은 표현식이므로 할당 가능, 결과값 20)
- 3번: 에러 (선언문은 표현식이 아님)
- 4번: 정상 (비교 표현식 결과인 boolean 값을 할당)
</details>

### 문제 4: 세미콜론 자동 삽입

다음 코드의 실행 결과를 예측하고, ASI가 어떻게 동작했는지 설명하시오.

```jsx
function getValue() {
  return
  {
    value: 42
  }
}

console.log(getValue());
```

<details>
<summary>해답 보기</summary>

**실행 결과:** `undefined`

**ASI의 동작:**
ASI가 `return` 다음에 자동으로 세미콜론을 삽입하여 다음과 같이 해석:

```jsx
function getValue() {
  return;  // undefined 반환
  {        // 도달할 수 없는 코드
    value: 42
  }
}
```

**올바른 작성법:**
```jsx
function getValue() {
  return {
    value: 42
  };
}
// 또는
function getValue() {
  return { value: 42 };
}
```
</details>

### 문제 5: 실무 시나리오

다음 상황에서 각각 표현식과 문을 사용하여 코드를 작성하시오.

**상황 1:** 사용자의 나이를 변수에 저장하고, 20세 이상인지 확인하여 결과를 다른 변수에 저장

**상황 2:** 배열의 모든 요소를 2배로 만드는 코드 작성 (map 사용)

<details>
<summary>해답 보기</summary>

**상황 1:**
```jsx
var age = 25;                    // 선언문과 할당문
var isAdult = age >= 20;         // 표현식 (비교 연산)의 결과를 변수에 할당
console.log(isAdult);            // true
```

**상황 2:**
```jsx
var numbers = [1, 2, 3, 4, 5];
var doubled = numbers.map(function(num) {
  return num * 2;                // 표현식: num * 2
});
console.log(doubled);            // [2, 4, 6, 8, 10]

// 또는 화살표 함수 사용
var doubled = numbers.map(num => num * 2);  // 더 간결한 표현식
```
</details>

---

## 심화 학습: 표현식의 평가 순서

복잡한 표현식이 평가될 때는 **연산자 우선순위**와 **결합성**에 따라 순서가 결정된다.

**연산자 우선순위 예시:**

```jsx
var result = 10 + 5 * 2;  // 20 (곱셈이 덧셈보다 우선)
```

평가 순서:
1. `5 * 2` → 10
2. `10 + 10` → 20

**괄호를 사용한 명시적 우선순위 지정:**

```jsx
var result = (10 + 5) * 2;  // 30 (괄호 안이 먼저 평가)
```

평가 순서:
1. `(10 + 5)` → 15
2. `15 * 2` → 30

**결합성 예시:**

```jsx
var x = 1;
x = x + 1;  // 우변의 표현식이 먼저 평가된 후 좌변에 할당
```

평가 순서:
1. 우변 `x + 1` 평가 → 2
2. 좌변 `x`에 2 할당

## 심화 학습: 부수 효과가 있는 표현식

대부분의 표현식은 값을 생성할 뿐 다른 영향을 주지 않지만, 일부 표현식은 **부수 효과(Side Effect)**를 가진다.

**할당 표현식:**

```jsx
var x = 1;
x = 10;  // x의 값을 변경하는 부수 효과
```

**증감 연산자:**

```jsx
var x = 5;
x++;     // x의 값을 6으로 변경 (부수 효과), 표현식의 값은 5
++x;     // x의 값을 7로 변경 (부수 효과), 표현식의 값은 7
```

**함수 호출:**

```jsx
var arr = [1, 2, 3];
arr.push(4);  // 배열을 변경하는 부수 효과
```

부수 효과를 가진 표현식은 프로그램의 상태를 변경하므로, 사용 시 주의가 필요하다. 함수형 프로그래밍에서는 부수 효과를 최소화하여 코드의 예측 가능성을 높이는 것을 지향한다.
