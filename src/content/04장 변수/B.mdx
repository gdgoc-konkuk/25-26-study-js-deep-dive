# 4장 변수

## 4-1. 변수의 개념과 필요성

프로그래밍에서 변수는 가장 기본적이면서도 필수적인 개념이다. 변수의 본질을 이해하기 위해서는 먼저 컴퓨터가 어떻게 연산을 수행하는지 살펴볼 필요가 있다.

다음의 자바스크립트 코드를 고려해보자.

```jsx
10 + 20;
```

이 간단한 덧셈 연산이 실행되는 과정은 인간과 컴퓨터가 근본적으로 다르다.

**인간의 연산 과정:**

1. 숫자 10, 20, 그리고 연산자 +의 의미를 각각 인지하고 해석한다.
2. 두 피연산자를 단기 기억에 보관한다.
3. 덧셈을 수행하여 결과값 30을 도출하고 이를 기억한다.

**컴퓨터의 연산 과정:**

컴퓨터는 CPU와 메모리의 협업을 통해 연산을 수행한다.

1. **메모리 구조의 이해**
   
   메모리는 데이터를 저장할 수 있는 메모리 셀(Memory Cell)들의 집합체이다.
   
   ![image.png](/images/ch04/ch4_a1.png)
   
   - 각 메모리 셀의 크기는 1바이트(8비트)이다.
   - 컴퓨터는 모든 데이터를 2진수 형태로 저장한다.
   - 각 메모리 셀은 고유한 메모리 주소를 가지며, 이는 메모리 공간의 위치를 나타낸다.
   - 메모리에 대한 모든 접근(저장 및 읽기)은 셀 단위로 이루어진다.

2. **연산 수행 과정**
   
   - 피연산자 10과 20을 각각 메모리에 저장한다.
   - CPU가 저장된 값들을 읽어와 덧셈 연산을 수행한다.
   - 연산 결과인 30을 새로운 메모리 공간에 저장한다.
   
   ![또다른 메모리 셀에 30이 저장된다](/images/ch04/ch4_a2.png)

**자바스크립트의 메모리 접근 제약**

중요한 점은, 자바스크립트에서는 연산 결과를 재사용하기 위해 **메모리 주소에 직접 접근할 수 없다**는 것이다. C나 C++과 같이 포인터를 지원하는 언어와 달리, 자바스크립트는 개발자가 메모리 주소를 통해 값에 직접 접근하는 것을 허용하지 않는다.

이러한 설계는 다음과 같은 이유에서 비롯된다:

- 동일한 코드를 실행하더라도 값이 저장되는 메모리 주소는 실행 시점마다 달라질 수 있다.
- 직접적인 메모리 접근은 시스템의 안정성과 보안에 위협이 될 수 있다.
- 메모리 관리의 복잡성으로부터 개발자를 해방시켜 생산성을 높인다.

따라서 자바스크립트는 **변수**라는 메커니즘을 통해 값에 간접적으로 접근하는 방식을 채택하고 있다.

### 4-1-1. 변수의 정의

**변수(Variable)**는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체, 또는 그 메모리 공간을 식별하기 위해 부여한 이름을 의미한다.

본질적으로 변수는 **값의 위치를 가리키는 식별자**라고 할 수 있다.

변수를 사용하여 앞의 예제를 재작성하면 다음과 같다:

```jsx
var result = 10 + 20;
```

**변수의 구성 요소:**

- **변수명(Variable Name)**: 메모리 공간에 붙인 이름 (예: `result`)
- **변수값(Variable Value)**: 변수에 저장된 값 (예: 30)
- **할당(Assignment)**: 변수에 값을 저장하는 행위 (메모리에 쓰기, Write)
- **참조(Reference)**: 변수에 저장된 값을 읽어오는 행위 (메모리에서 읽기, Read)

![image.png](/images/ch04/ch4_a3.png)

변수를 통해 개발자는 메모리 주소를 직접 다루지 않고도 값을 안전하게 저장하고 참조할 수 있다.

## 4-2. 식별자의 개념

**식별자(Identifier)**는 어떤 값이 저장된 메모리 주소를 가리키는 이름이다.

핵심은 식별자가 값 자체가 아닌 **메모리 주소를 기억**한다는 점이다.

![값은 구별하지 못 하고 메모리 주소를 구별한다.](/images/ch04/ch4_a4.png)

식별자는 변수에만 국한되지 않는다. 함수, 클래스 등 메모리 상에 존재하는 모든 값을 식별할 수 있는 이름은 모두 식별자로 분류된다.

**식별자의 중요한 특성:**

- 네이밍 규칙을 반드시 준수해야 한다.
- 선언(Declaration)을 통해 자바스크립트 엔진에 식별자의 존재를 알려야 한다.
- 식별자의 이름만으로도 그것이 가리키는 값의 의미를 파악할 수 있어야 한다.

변수명은 코드의 가독성과 유지보수성에 직접적인 영향을 미치므로, 신중하게 명명해야 한다. 좋은 변수명은 클린 코드의 시작점이라 할 수 있다.

## 4-3. 변수 선언

**변수 선언(Variable Declaration)**은 변수를 생성하는 것을 의미한다. 구체적으로는 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 해당 메모리 공간의 주소를 연결하는 과정이다.

### 4-3-1. 변수 선언 키워드

자바스크립트는 변수 선언을 위해 다음 세 가지 키워드를 제공한다:

- `var` (ES5 이하)
- `let` (ES6 이상)
- `const` (ES6 이상)

**var 키워드를 사용한 변수 선언**

`var` 키워드로 변수를 선언하면 다음 두 단계가 동시에 진행된다:

1. **선언 단계(Declaration Phase)**: 변수 이름을 실행 컨텍스트에 등록하고 메모리 공간을 확보한다.

   ```jsx
   var score;
   ```

2. **초기화 단계(Initialization Phase)**: 자바스크립트 엔진이 암묵적으로 `undefined` 값을 할당하여 변수를 초기화한다.

   ![image.png](/images/ch04/ch4_a5.png)

이러한 초기화 과정은 메모리 공간에 이전에 존재하던 쓰레기 값(Garbage Value)으로 인한 예기치 않은 동작을 방지한다.

그러나 `var` 키워드는 함수 레벨 스코프, 변수 호이스팅, 중복 선언 허용 등 여러 문제점을 가지고 있어, 현대적인 자바스크립트 개발에서는 `let`과 `const`의 사용이 권장된다.

### 4-3-2. 선언되지 않은 식별자 참조

선언되지 않은 식별자에 접근하려 시도하면 `ReferenceError`(참조 에러)가 발생한다. 이는 자바스크립트 엔진이 해당 이름으로 등록된 식별자를 찾을 수 없음을 의미한다.

```jsx
console.log(undeclaredVariable); // ReferenceError: undeclaredVariable is not defined
```

## 4-4. 변수 선언의 실행 시점과 변수 호이스팅

**변수 호이스팅(Variable Hoisting)**은 변수 선언문이 코드의 최상단으로 끌어올려진 것처럼 동작하는 자바스크립트의 고유한 특성이다.

다음 예제를 살펴보자:

```jsx
console.log(score); // undefined

var score;
```

일반적인 프로그래밍 언어라면 선언 전에 변수를 참조하려 할 때 오류가 발생할 것으로 예상된다. 그러나 자바스크립트는 `ReferenceError`를 발생시키지 않고 `undefined`를 출력한다.

**호이스팅이 발생하는 이유:**

자바스크립트 엔진은 코드를 실행하기 전에 소스코드를 평가하는 과정을 거친다. 이 평가 과정에서 모든 선언문(변수 선언, 함수 선언 등)을 찾아내어 먼저 실행한다. 따라서 변수 선언이 코드의 어디에 위치하든 다른 코드보다 먼저 실행된다.

**호이스팅의 동작 예시:**

```jsx
console.log(x); // undefined (선언은 되었으나 할당은 안 됨)
var x = 100;
console.log(x); // 100 (할당 후)
```

위 코드는 자바스크립트 엔진에 의해 다음과 같이 해석된다:

```jsx
var x;              // 선언 및 초기화 (호이스팅)
console.log(x);     // undefined
x = 100;            // 할당
console.log(x);     // 100
```

`var` 키워드는 선언과 초기화가 동시에 이루어지므로, 호이스팅된 시점에서 이미 `undefined` 값을 가지게 된다.

### 4-4-1. let과 const의 호이스팅

`let`과 `const` 키워드로 선언한 변수도 호이스팅이 발생한다. 하지만 `var`와는 다른 방식으로 동작한다.

```jsx
console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 20;

console.log(c); // ReferenceError: Cannot access 'c' before initialization
const c = 30;
```

**let과 const의 호이스팅 특징:**

- 선언은 호이스팅되지만, 초기화는 호이스팅되지 않는다.
- 선언 시점부터 초기화 시점까지를 **일시적 사각지대(Temporal Dead Zone, TDZ)**라고 한다.
- TDZ 구간에서 변수에 접근하려 하면 `ReferenceError`가 발생한다.
- 블록 레벨 스코프를 따르므로 블록 내에서만 접근 가능하다.

이러한 차이는 `let`과 `const`가 `var`의 문제점을 개선하기 위해 설계되었음을 보여준다.

## 4-5. 값의 할당

변수에 값을 할당하기 위해서는 **할당 연산자 `=`**를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.

```jsx
var score = 80;
```

**변수 선언과 값 할당의 실행 시점:**

- **변수 선언**: 소스코드 평가 과정에서 실행 (호이스팅)
- **값 할당**: 런타임(Runtime)에 순차적으로 실행

이 차이를 명확히 이해하는 것이 중요하다.

```jsx
console.log(score); // undefined (선언은 호이스팅됨)

var score;          // 선언
score = 80;         // 할당 (런타임에 실행)

console.log(score); // 80
```

**주목할 만한 예제:**

```jsx
console.log(score); // undefined

score = 80;         // 할당이 먼저 작성됨
var score;          // 선언이 나중에 작성됨

console.log(score); // 80
```

![image.png](/images/ch04/ch4_a6.png)

선언과 할당의 순서가 코드 상에서 바뀌어도 결과는 동일하다. 이는 선언이 항상 호이스팅되어 먼저 실행되기 때문이다.

## 4-6. 값의 재할당

### 4-6-1. 재할당의 개념

**재할당(Reassignment)**은 이미 값이 할당된 변수에 새로운 값을 할당하여, 기존 값을 버리고 새로운 값으로 교체하는 것을 의미한다.

**재할당 가능 여부에 따른 분류:**

- `var`, `let`: 재할당 가능 (변수, Variable)
- `const`: 재할당 불가능 (상수, Constant)

```jsx
let mutableValue = 10;
mutableValue = 20;        // 재할당 가능

const immutableValue = 10;
immutableValue = 20;      // TypeError: Assignment to constant variable
```

### 4-6-2. 재할당의 내부 동작 원리

재할당이 발생하면 메모리 공간에서 어떤 일이 일어나는지 이해하는 것이 중요하다.

![image.png](/images/ch04/ch4_a7.png)

**재할당 과정:**

1. 변수 `score`는 처음 `undefined`로 초기화된 메모리 공간을 가리킨다.
2. `score = 80` 할당 시, 새로운 메모리 공간을 확보하고 80을 저장한 후, `score`가 이 새로운 공간을 가리키도록 한다.
3. `score = 90` 재할당 시, 또 다른 새로운 메모리 공간을 확보하고 90을 저장한 후, `score`가 이 공간을 가리키도록 한다.

**핵심 포인트:**

- 재할당은 변수가 가리키는 메모리 주소를 변경하는 것이다.
- 이전 값이 저장된 메모리 공간은 더 이상 참조되지 않게 된다.
- 참조되지 않는 메모리 공간은 가비지 컬렉터(Garbage Collector)에 의해 자동으로 해제된다.
- 메모리 해제 시점은 예측할 수 없으며, 개발자가 직접 제어할 수도 없다.

**가비지 컬렉션(Garbage Collection)**

가비지 컬렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여, 더 이상 사용되지 않는 메모리를 자동으로 해제하는 기능이다. 이는 메모리 누수를 방지하고 효율적인 메모리 관리를 가능하게 한다.

## 4-7. 식별자 네이밍 규칙

변수의 이름을 정하는 것은 단순한 작업이 아니다. 좋은 변수명은 코드의 의도를 명확히 전달하고, 유지보수성을 크게 향상시킨다.

**네이밍 규칙 (Naming Rules):**

1. 식별자는 문자, 숫자, 언더스코어(`_`), 달러 기호(`$`)만 포함할 수 있다.
2. 숫자로 시작할 수 없다. (첫 문자는 문자, `_`, `$` 중 하나여야 함)
3. [예약어(Reserved Word)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_words)는 식별자로 사용할 수 없다.

**올바른 예시:**

```jsx
var firstName;
var _privateVar;
var $jquery;
var value1;
```

**잘못된 예시:**

```jsx
var 1stPlace;      // 숫자로 시작
var my-var;        // 하이픈 사용 불가
var for;           // 예약어 사용 불가
```

### 4-7-1. 네이밍 컨벤션

**네이밍 컨벤션(Naming Convention)**은 일관된 코딩 스타일을 유지하기 위한 명명 규약이다.

**주요 네이밍 컨벤션 유형:**

1. **카멜 케이스(camelCase)** - 변수, 함수명에 사용
   ```jsx
   let userName;
   let getUserInfo;
   ```

2. **파스칼 케이스(PascalCase)** - 생성자 함수, 클래스명에 사용
   ```jsx
   class UserAccount;
   function Person() {}
   ```

3. **스네이크 케이스(snake_case)** - 주로 데이터베이스 필드명 등에 사용
   ```jsx
   let user_name;
   ```

4. **헝가리언 케이스(Hungarian Case)** - 타입 접두사 포함 (현대적 개발에서는 비권장)
   ```jsx
   let strUserName;  // str: string 타입 의미
   ```

**권장 사항:**

- 자바스크립트에서는 일반적으로 변수와 함수는 카멜 케이스를, 생성자 함수와 클래스는 파스칼 케이스를 사용한다.
- 일관성을 유지하는 것이 가장 중요하다.
- 변수명은 그 용도와 의미를 명확히 전달해야 한다.

---

## 학습 점검 문제

### 문제 1: 호이스팅의 이해
다음 코드의 실행 결과를 예측하고, 그 이유를 설명하시오.

```jsx
console.log(a);
console.log(b);
console.log(c);

var a = 1;
let b = 2;
const c = 3;
```

<details>
<summary>해답 보기</summary>

**실행 결과:**
- `console.log(a)`: `undefined` 출력
- `console.log(b)`: `ReferenceError` 발생
- `console.log(c)`는 실행되지 않음 (이전 라인에서 에러 발생)

**이유:**
- `var a`는 호이스팅되며 `undefined`로 초기화됨
- `let b`와 `const c`도 호이스팅되지만 TDZ에 있어 초기화 전 접근 시 에러 발생
</details>

### 문제 2: 재할당과 메모리
다음 코드가 실행될 때 메모리에서 일어나는 일을 설명하시오.

```jsx
let value = 10;
value = 20;
value = 30;
```

<details>
<summary>해답 보기</summary>

1. `let value` 선언 시 메모리 공간 확보
2. `value = 10` 할당 시 첫 번째 메모리 공간에 10 저장
3. `value = 20` 재할당 시 새로운 메모리 공간 확보 후 20 저장, value는 새 공간 참조
4. `value = 30` 재할당 시 또 다른 메모리 공간 확보 후 30 저장, value는 이 공간 참조
5. 10과 20이 저장된 메모리 공간은 더 이상 참조되지 않아 가비지 컬렉션 대상이 됨
</details>

### 문제 3: 식별자와 값
다음 중 올바른 설명을 모두 고르시오.

A. 식별자는 값 자체를 저장한다.
B. 식별자는 메모리 주소를 기억한다.
C. 변수명은 식별자의 한 종류이다.
D. 함수명은 식별자가 아니다.

<details>
<summary>해답 보기</summary>

**정답: B, C**

- A (X): 식별자는 값이 아닌 메모리 주소를 저장함
- B (O): 식별자의 핵심 개념
- C (O): 변수명, 함수명, 클래스명 모두 식별자
- D (X): 함수명도 식별자에 해당함
</details>

### 문제 4: const의 특성
다음 코드에서 에러가 발생하는 라인과 그 이유를 설명하시오.

```jsx
const obj = { value: 10 };
obj.value = 20;
obj = { value: 30 };
```

<details>
<summary>해답 보기</summary>

**에러 발생 라인:** 3번째 줄

**이유:**
- `const`는 재할당을 금지함
- 2번째 줄은 객체의 프로퍼티를 변경하는 것이므로 허용됨 (재할당이 아님)
- 3번째 줄은 `obj` 자체에 새로운 객체를 재할당하려 하므로 `TypeError` 발생
</details>

### 문제 5: 실무 시나리오
다음 중 가장 적절한 변수 선언 방법과 그 이유를 설명하시오.

```jsx
// 시나리오 1: 사용자의 나이를 저장 (값이 변경될 수 있음)
// 시나리오 2: 원주율 파이(π) 값 저장
// 시나리오 3: 반복문의 카운터 변수
```

<details>
<summary>해답 보기</summary>

**시나리오 1:** `let age = 25;`
- 나이는 변경될 수 있으므로 재할당 가능한 `let` 사용

**시나리오 2:** `const PI = 3.14159;`
- 상수 값이므로 재할당 불가능한 `const` 사용
- 상수는 대문자와 언더스코어로 표기하는 것이 관례

**시나리오 3:** `for (let i = 0; i < 10; i++)`
- 블록 스코프가 필요한 반복문에서는 `let` 사용
- `var`는 함수 스코프이므로 예상치 못한 동작을 유발할 수 있음
</details>

---

## 심화 학습: 실행 컨텍스트와 변수

변수가 어떻게 관리되는지 더 깊이 이해하기 위해서는 **실행 컨텍스트(Execution Context)**의 개념을 알아야 한다.

실행 컨텍스트는 코드의 실행 환경을 나타내는 추상적인 개념으로, 다음 정보를 포함한다:

- **변수 환경(Variable Environment)**: 변수와 함수 선언 정보
- **렉시컬 환경(Lexical Environment)**: 식별자와 값의 매핑 관계
- **this 바인딩**: this 값의 결정

자바스크립트 엔진은 실행 컨텍스트를 통해 변수의 생명주기, 스코프, 호이스팅 등을 관리한다. 이는 23장에서 더 자세히 다루게 될 것이다.
