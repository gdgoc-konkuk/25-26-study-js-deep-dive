// PR ìë™ ë§¤ì¹­ ë° ìƒì„± ë¡œì§ (í•µì‹¬!)

import type { Octokit } from '@octokit/rest';
import { getBotClient, getRepositoryInfo } from './github';

/**
 * íŒŒì¼ ê²½ë¡œë¡œ PR ê²€ìƒ‰
 * @param filePath - íŒŒì¼ ê²½ë¡œ (ì˜ˆ: "docs/01-ë³€ìˆ˜.mdx")
 * @returns í•´ë‹¹ íŒŒì¼ì„ ìˆ˜ì •í•œ PR ëª©ë¡
 */
export async function searchPRsByFile(
  filePath: string,
  autoGeneratedOnly: boolean = false
): Promise<Array<{ number: number; merged_at: string | null }>> {
  const octokit = await getBotClient();
  const { owner, repo } = getRepositoryInfo();

  try {
    // ëª¨ë“  merged PR ê°€ì ¸ì˜¤ê¸° (ìµœì‹ ìˆœ)
    const { data: prs } = await octokit.pulls.list({
      owner,
      repo,
      state: 'closed', // merged PRì€ closed ìƒíƒœ
      sort: 'updated',
      direction: 'desc',
      per_page: 100, // ìµœê·¼ 100ê°œ PR ê²€ìƒ‰
    });

    // ê° PRì˜ ì œëª©ìœ¼ë¡œ ë§¤ì¹­ í™•ì¸
    const matchingPRs: Array<{ number: number; merged_at: string | null }> =
      [];

    for (const pr of prs) {
      // mergedëœ PRë§Œ í™•ì¸
      if (!pr.merged_at) continue;

      // ìë™ ìƒì„± PRë§Œ ì°¾ëŠ” ê²½ìš°, ì œëª© íŒ¨í„´ìœ¼ë¡œ í•„í„°ë§
      if (autoGeneratedOnly) {
        // ì œëª© íŒ¨í„´: [Comments] ì „ì²´/íŒŒì¼/ê²½ë¡œ.mdx
        const expectedTitle = `[Comments] ${filePath}`;
        if (pr.title === expectedTitle) {
          console.log(`âœ“ ì œëª© ë§¤ì¹­ ì„±ê³µ: PR #${pr.number} - ${pr.title}`);
          matchingPRs.push({
            number: pr.number,
            merged_at: pr.merged_at,
          });
        }
      } else {
        // ì¼ë°˜ PRì€ ë³€ê²½ íŒŒì¼ ëª©ë¡ìœ¼ë¡œ í™•ì¸
        const { data: files } = await octokit.pulls.listFiles({
          owner,
          repo,
          pull_number: pr.number,
        });

        const hasFile = files.some((file) => file.filename === filePath);
        if (hasFile) {
          matchingPRs.push({
            number: pr.number,
            merged_at: pr.merged_at,
          });
        }
      }
    }

    return matchingPRs;
  } catch (error) {
    console.error('PR ê²€ìƒ‰ ì‹¤íŒ¨:', error);
    return [];
  }
}

/**
 * ìµœì‹  merged PR ì„ íƒ
 * @param prs - PR ëª©ë¡
 * @returns ê°€ì¥ ìµœì‹  PR ë²ˆí˜¸ ë˜ëŠ” null
 */
export function getLatestMergedPR(
  prs: Array<{ number: number; merged_at: string | null }>
): number | null {
  if (prs.length === 0) return null;

  // merged_at ê¸°ì¤€ ì •ë ¬ (ìµœì‹ ìˆœ)
  const sorted = prs
    .filter((pr) => pr.merged_at !== null)
    .sort(
      (a, b) =>
        new Date(b.merged_at!).getTime() - new Date(a.merged_at!).getTime()
    );

  return sorted[0]?.number || null;
}

/**
 * ëŒ“ê¸€ ì „ìš© PR ìƒì„± ë° ì¦‰ì‹œ ë³‘í•©
 * @param filePath - íŒŒì¼ ê²½ë¡œ
 * @returns ìƒì„±ëœ PR ë²ˆí˜¸
 */
export async function createAndMergeCommentPR(
  filePath: string
): Promise<number> {
  const octokit = await getBotClient();
  const { owner, repo } = getRepositoryInfo();

  // íŒŒì¼ëª… ì¶”ì¶œ
  const fileName = filePath.split('/').pop() || filePath;

  try {
    // 1. ê¸°ë³¸ ë¸Œëœì¹˜ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    const { data: repoData } = await octokit.repos.get({
      owner,
      repo,
    });
    const baseBranch = repoData.default_branch;

    // 2. ê¸°ë³¸ ë¸Œëœì¹˜ì˜ ìµœì‹  ì»¤ë°‹ SHA ê°€ì ¸ì˜¤ê¸°
    const { data: baseRef } = await octokit.git.getRef({
      owner,
      repo,
      ref: `heads/${baseBranch}`,
    });
    const baseSha = baseRef.object.sha;

    // ê¸°ë³¸ ë¸Œëœì¹˜ì˜ ì»¤ë°‹ì—ì„œ tree SHA ê°€ì ¸ì˜¤ê¸°
    const { data: baseCommit } = await octokit.git.getCommit({
      owner,
      repo,
      commit_sha: baseSha,
    });
    const treeSha = baseCommit.tree.sha;

    // 3. ìƒˆ ë¸Œëœì¹˜ ìƒì„± (comments/íŒŒì¼ëª…-íƒ€ì„ìŠ¤íƒ¬í”„)
    const branchName = `comments/${fileName}-${Date.now()}`;
    await octokit.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${branchName}`,
      sha: baseSha,
    });

    // 4. ë¹ˆ ì»¤ë°‹ ìƒì„± (PRì„ ìœ„í•´ ì»¤ë°‹ í•„ìš”)
    const { data: commit } = await octokit.git.createCommit({
      owner,
      repo,
      message: `[Comments] Auto-generated PR for ${fileName}`,
      tree: treeSha, // tree SHA ì‚¬ìš© (ì»¤ë°‹ SHAê°€ ì•„ë‹˜)
      parents: [baseSha],
    });

    // 5. ë¸Œëœì¹˜ì— ì»¤ë°‹ ì ìš©
    await octokit.git.updateRef({
      owner,
      repo,
      ref: `heads/${branchName}`,
      sha: commit.sha,
    });

    // 6. PR ìƒì„±
    const { data: pr } = await octokit.pulls.create({
      owner,
      repo,
      title: `[Comments] ${fileName}`,
      head: branchName,
      base: baseBranch,
      body: `ì´ PRì€ \`${filePath}\` íŒŒì¼ì— ëŒ€í•œ ëŒ“ê¸€ì„ ìœ„í•´ ìë™ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.\n\n**ì£¼ì˜**: ì´ PRì€ ìë™ìœ¼ë¡œ ë³‘í•©ë˜ë©°, ì‹¤ì œ ì½”ë“œ ë³€ê²½ ì‚¬í•­ì€ ì—†ìŠµë‹ˆë‹¤.`,
    });

    // 7. ë ˆì´ë¸” ì¶”ê°€
    await octokit.issues.addLabels({
      owner,
      repo,
      issue_number: pr.number,
      labels: ['comments', 'auto-generated'],
    });

    // 8. PR ì¦‰ì‹œ ë³‘í•©
    await octokit.pulls.merge({
      owner,
      repo,
      pull_number: pr.number,
      commit_title: `[Comments] Auto-merge PR for ${fileName}`,
      merge_method: 'merge', // merge commit ìƒì„±
    });

    console.log(`âœ… ëŒ“ê¸€ ì „ìš© PR #${pr.number} ìƒì„± ë° ë³‘í•© ì™„ë£Œ: ${filePath}`);

    return pr.number;
  } catch (error) {
    console.error('PR ìƒì„± ë° ë³‘í•© ì‹¤íŒ¨:', error);
    throw new Error(`PR ìƒì„± ì‹¤íŒ¨: ${error instanceof Error ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`);
  }
}

/**
 * íŒŒì¼ ê²½ë¡œë¡œ íƒ€ê²Ÿ PR ì°¾ê¸° ë˜ëŠ” ìƒì„±
 * @param filePath - íŒŒì¼ ê²½ë¡œ
 * @returns PR ë²ˆí˜¸
 */
export async function getOrCreateTargetPR(filePath: string): Promise<number> {
  console.log(`ğŸ” íŒŒì¼ì— ëŒ€í•œ PR ê²€ìƒ‰ ì¤‘: ${filePath}`);

  // 1. ë¨¼ì € ìë™ ìƒì„±ëœ ëŒ“ê¸€ PR ê²€ìƒ‰
  const autoGeneratedPRs = await searchPRsByFile(filePath, true);
  const latestAutoGeneratedPR = getLatestMergedPR(autoGeneratedPRs);

  if (latestAutoGeneratedPR) {
    console.log(`âœ… ê¸°ì¡´ ìë™ ìƒì„± ëŒ“ê¸€ PR ì°¾ìŒ: #${latestAutoGeneratedPR}`);
    return latestAutoGeneratedPR;
  }

  // 2. ìë™ ìƒì„± PRì´ ì—†ìœ¼ë©´, ì¼ë°˜ PR ê²€ìƒ‰ (í•˜ìœ„ í˜¸í™˜ì„±)
  const prs = await searchPRsByFile(filePath, false);
  const latestPR = getLatestMergedPR(prs);

  if (latestPR) {
    console.log(`âœ… ê¸°ì¡´ ì¼ë°˜ PR ì°¾ìŒ: #${latestPR}`);
    return latestPR;
  }

  // 3. ê¸°ì¡´ PRì´ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„± ë° ë³‘í•©
  console.log(`ğŸ“ ê¸°ì¡´ PRì´ ì—†ìŠµë‹ˆë‹¤. ìƒˆ PR ìƒì„± ì¤‘...`);
  const newPR = await createAndMergeCommentPR(filePath);

  return newPR;
}
